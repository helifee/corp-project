<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	   xmlns:aop="http://www.springframework.org/schema/aop"
	   xmlns:tx="http://www.springframework.org/schema/tx"
	   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd
           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd"
	   default-autowire="byName" default-lazy-init="false">

	<bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"> 
	   <property name="location" value="classpath:/jdbc.properties"/> 
	</bean> 

	<bean id="dataSource" class="com.yds.util.service.DynamicDataSource"> 
		<property name="targetDataSources">
			<map key-type="java.lang.String">
				<entry key="ds0" value-ref="ds0"/>
                <entry key="ds1" value-ref="ds1"/>
                <entry key="ds2" value-ref="ds2"/>
            </map>
         </property>
         <property name="defaultTargetDataSource" ref="ds0"/>
     </bean> 		
	<!-- 数据库连接池c3p0配置 -->
	<bean id="ds0"
        class="com.mchange.v2.c3p0.ComboPooledDataSource"
        destroy-method="close">
        <property name="driverClass">
            <value>${jdbc.driverclass}</value>
        </property>
        <property name="jdbcUrl">
            <value>jdbc:mysql://${jdbc.dbhost}:${jdbc.port}/${jdbc.database}?zeroDateTimeBehavior=convertToNull&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;autoReconnect=true</value>
        </property>
		<!-- 下面4个参数尝试解决8小时超时问题-->
        <property name="maxIdleTime">
            <value>25000</value>
        </property>
        <property name="idleConnectionTestPeriod">
            <value>18000</value>
        </property>
        <property name="testConnectionOnCheckin">
            <value>true</value>
        </property>
        <property name="preferredTestQuery">
            <value>select 1</value>
        </property>
		<property name="properties">
            <props>
                <prop key="c3p0.minPoolSize">2</prop>
                <prop key="c3p0.maxPoolSize">50</prop>
				<!-- 获得连接的超时时间,如果超过这个时间,会抛出异常，单位毫秒 -->
                <prop key="c3p0.timeout">6000</prop> <!-- seconds --><!-- default: 0 -->
				<!-- 最大的PreparedStatement的数量 -->
                <prop key="c3p0.max_statement">100</prop> <!-- default: 0 -->
                <prop key="c3p0.acquire_increment">1</prop> <!-- default: 1 -->
                <!-- 每隔120秒检查连接池里的空闲连接 ，单位是秒-->
                <prop key="c3p0.idle_test_period">120</prop>
                <prop key="c3p0.testConnectionOnCheckout">true</prop>
				<!-- 每次都验证连接是否可用 -->
                <prop key="c3p0.validate">true</prop> 
                <!-- 当连接池里面的连接用完的时候，C3P0一下获取的新的连接数 -->
                <prop key="c3p0.acquire_increment">2</prop>
                <prop key="user">${jdbc.user}</prop>
                <prop key="password">${jdbc.password}</prop>

           </props>
        </property>
	</bean>
	<!-- 数据库连接池c3p0配置 -->
	<bean id="ds1"
        class="com.mchange.v2.c3p0.ComboPooledDataSource"
        destroy-method="close">
        <property name="driverClass">
            <value>${jdbc2.driverclass}</value>
        </property>
        <property name="jdbcUrl">
            <value>jdbc:mysql://${jdbc2.dbhost}:${jdbc2.port}/${jdbc2.database}?zeroDateTimeBehavior=convertToNull&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;autoReconnect=true</value>
        </property>
		<!-- 下面4个参数尝试解决8小时超时问题-->
        <property name="maxIdleTime">
            <value>25000</value>
        </property>
        <property name="idleConnectionTestPeriod">
            <value>18000</value>
        </property>
        <property name="testConnectionOnCheckin">
            <value>true</value>
        </property>
        <property name="preferredTestQuery">
            <value>select 1</value>
        </property>
		
        <property name="properties">
            <props>
                <prop key="c3p0.minPoolSize">2</prop>
                <prop key="c3p0.maxPoolSize">50</prop>
				<!-- 获得连接的超时时间,如果超过这个时间,会抛出异常，单位毫秒 -->
                <prop key="c3p0.timeout">6000</prop> <!-- seconds --><!-- default: 0 -->
				<!-- 最大的PreparedStatement的数量 -->
                <prop key="c3p0.max_statement">100</prop> <!-- default: 0 -->
                <prop key="c3p0.acquire_increment">1</prop> <!-- default: 1 -->
                <!-- 每隔120秒检查连接池里的空闲连接 ，单位是秒-->
                <prop key="c3p0.idle_test_period">120</prop>
                <prop key="c3p0.testConnectionOnCheckout">true</prop>
				<!-- 每次都验证连接是否可用 -->
                <prop key="c3p0.validate">true</prop> 
                <!-- 当连接池里面的连接用完的时候，C3P0一下获取的新的连接数 -->
                <prop key="c3p0.acquire_increment">2</prop>
                <prop key="user">${jdbc2.user}</prop>
                <prop key="password">${jdbc2.password}</prop>

				
            </props>
        </property>
	</bean>
	
	<!-- 数据库连接池c3p0配置 -->
	<bean id="ds2"
        class="com.mchange.v2.c3p0.ComboPooledDataSource"
        destroy-method="close">
        <property name="driverClass">
            <value>${jdbc3.driverclass}</value>
        </property>
        <property name="jdbcUrl">
            <value>jdbc:mysql://${jdbc3.dbhost}:${jdbc3.port}/${jdbc3.database}?zeroDateTimeBehavior=convertToNull&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;autoReconnect=true</value>
        </property>
		<!-- 下面4个参数尝试解决8小时超时问题-->
        <property name="maxIdleTime">
            <value>25000</value>
        </property>
        <property name="idleConnectionTestPeriod">
            <value>18000</value>
        </property>
        <property name="testConnectionOnCheckin">
            <value>true</value>
        </property>
        <property name="preferredTestQuery">
            <value>select 1</value>
        </property>
		
        <property name="properties">
            <props>
                <prop key="c3p0.minPoolSize">2</prop>
                <prop key="c3p0.maxPoolSize">50</prop>
				<!-- 获得连接的超时时间,如果超过这个时间,会抛出异常，单位毫秒 -->
                <prop key="c3p0.timeout">6000</prop> <!-- seconds --><!-- default: 0 -->
				<!-- 最大的PreparedStatement的数量 -->
                <prop key="c3p0.max_statement">100</prop> <!-- default: 0 -->
                <prop key="c3p0.acquire_increment">1</prop> <!-- default: 1 -->
                <!-- 每隔120秒检查连接池里的空闲连接 ，单位是秒-->
                <prop key="c3p0.idle_test_period">120</prop>
                <prop key="c3p0.testConnectionOnCheckout">true</prop>
				<!-- 每次都验证连接是否可用 -->
                <prop key="c3p0.validate">true</prop> 
                <!-- 当连接池里面的连接用完的时候，C3P0一下获取的新的连接数 -->
                <prop key="c3p0.acquire_increment">2</prop>
                <prop key="user">${jdbc3.user}</prop>
                <prop key="password">${jdbc3.password}</prop>

				
            </props>
        </property>
	</bean>

	
	<!-- 后台共通message数据源-->
	<bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">
		<property name="basenames">
			<list>
				<value>message</value>
				<value>com_parameter</value>
				<value>rss</value>
				<value>jdbc</value>
			</list>
		</property>
	</bean>

	<!-- 基本事务定义,使用transactionManager作事务管理,默认get* find*方法的事务为readonly,其余方法按默认设置.
			 默认的设置请参考Spring文档事务一章. -->
	<tx:advice id="txAdvice" transaction-manager="transactionManager">
		<tx:attributes>
			<!-- 只读事物 -->
			<tx:method name="find*" read-only="true"/>
			<tx:method name="get*" read-only="true"/>
			<tx:method name="query*" read-only="true"/>
			<!-- 遇异常回滚的事务 -->
			<!-- 
				事务等级 (isolation)
				ISOLATION_DEFAULT: 使用底层数据库预设的隔离层级 
				ISOLATION_READ_COMMITTED: 允许事务读取其他并行的事务已经送出（Commit）的数据字段，可以防止Dirty read问题 
				ISOLATION_READ_UNCOMMITTED: 允许事务读取其他并行的事务还没送出的数据，会发生Dirty、Nonrepeatable、Phantom read等问题 
				ISOLATION_REPEATABLE_READ: 要求多次读取的数据必须相同，除非事务本身更新数据，可防止Dirty、Nonrepeatable read问题 
				ISOLATION_SERIALIZABLE: 完整的隔离层级，可防止Dirty、Nonrepeatable、Phantom read等问题，会锁定对应的数据表格，因而有效率问题 
				
				传播性 (propagation)
				PROPAGATION_MANDATORY: 方法必须在一个现存的事务中进行，否则丢出异常 
				PROPAGATION_NESTED: 在一个嵌入的事务中进行，如果不是，则同PROPAGATION_REQUIRED 
				PROPAGATION_NEVER: 指出不应在事务中进行，如果有就丢出异常 
				PROPAGATION_NOT_SUPPORTED: 指出不应在事务中进行，如果有就暂停现存的事务 
				PROPAGATION_REQUIRED: 在当前的事务中进行，如果没有就建立一个新的事务 
				PROPAGATION_REQUIRES_NEW: 建立一个新的事务，如果现存一个事务就暂停它 
				PROPAGATION_SUPPORTS: 支持现在的事务，如果没有就以非事务的方式执行 

				
			-->
			<tx:method name="insert*" timeout="60" read-only="false" 
				propagation="REQUIRED" isolation="READ_COMMITTED"  rollback-for="Exception"/>   
			<tx:method name="add*" timeout="60" read-only="false" 
				propagation="REQUIRED" isolation="READ_COMMITTED"  rollback-for="Exception"/>   
			<tx:method name="save*" timeout="60" read-only="false" 
				propagation="REQUIRED" isolation="READ_COMMITTED"  rollback-for="Exception"/>   
			<tx:method name="update*" timeout="60" read-only="false" 
				propagation="REQUIRED" isolation="READ_COMMITTED"  rollback-for="Exception"/>   
			<tx:method name="delete*" timeout="60" read-only="false" 
				propagation="REQUIRED" isolation="READ_COMMITTED"  rollback-for="Exception"/>   
			<tx:method name="remove*" timeout="60" read-only="false" 
				propagation="REQUIRED" isolation="READ_COMMITTED"  rollback-for="Exception"/>   
			<tx:method name="login" timeout="60" read-only="false" 
				propagation="REQUIRED" isolation="READ_COMMITTED"  rollback-for="Exception"/>   
			<tx:method name="logging" timeout="60" read-only="false" 
				propagation="REQUIRED" isolation="READ_COMMITTED"  rollback-for="Exception"/>   
			<tx:method name="oldLogin" timeout="60" read-only="false" 
				propagation="REQUIRED" isolation="READ_COMMITTED"  rollback-for="Exception"/>   
			<tx:method name="getSequence" timeout="60" read-only="false" 
				propagation="REQUIRED" isolation="READ_COMMITTED"  rollback-for="Exception"/>
			<tx:method name="getNextSequence" timeout="60" read-only="false" 
				propagation="REQUIRED" isolation="READ_COMMITTED"  rollback-for="Exception"/>
			<tx:method name="tansfer" timeout="60" read-only="false" 
				propagation="REQUIRED" isolation="READ_COMMITTED"  rollback-for="Exception"/>   
			<tx:method name="jobRun" timeout="60" read-only="false" 
				propagation="REQUIRES_NEW" isolation="READ_COMMITTED"  rollback-for="Exception"/>			
			
			<tx:method name="*" read-only="true"/>
		</tx:attributes>
	</tx:advice>
	
	<!-- 支持 @Transactional 标记 -->
	<tx:annotation-driven/>

	<!-- 支持 @AspectJ 标记-->
<!--	<aop:aspectj-autoproxy/>-->

	<!-- 以AspectJ方式 定义 AOP -->
	<aop:config>
		<aop:pointcut id="servicesPointcut" expression="execution(* com.yds..*.service.impl.*.*(..))" />
		<aop:advisor advice-ref="txAdvice" pointcut-ref="servicesPointcut" />
	</aop:config>
	
	<bean class="com.yds.common.service.impl.ErrorLoggingAroundAspect"/>
	<aop:aspectj-autoproxy/>

	<!-- 用于持有ApplicationContext,可以使用ApplicationContextHolder.getBean('xxxx')的静态方法得到spring bean对象 -->
	<bean class="com.yds.util.service.ApplicationContextHolder"/>
	
</beans>