/*
 * @(#)SeleniumTestCase.java
 * Copyright (c) 2009-2010 大连远东计算机系统有限公司
 * All rights reserved.
 *      Project: 远东公司内部网
 *    SubSystem: 共通系统
 */
package com.yds.base.test;

import java.util.Arrays;
import java.util.Properties;
import java.util.regex.Pattern;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.runner.RunWith;
import org.springframework.core.io.support.PropertiesLoaderUtils;

import com.thoughtworks.selenium.DefaultSelenium;
import com.thoughtworks.selenium.Selenium;

/**
 * Selenium Web功能测试用例基类.
 * 
 * @author tianjian
 */
@RunWith(SeleniumTestRunner.class)
public class CoreSeleniumTest extends AbstractSpringTransTest {

	protected static final String PROPERTY_FILE = "com/yds/base/test/application.test.properties";

	protected static final String DEFAULT_URL = "http://localhost:8080/YDSWEB";
	protected static final String DEFAULT_BROWSER = "*iexplore";
	protected static final String DEFAULT_SELENIUM_HOST = "localhost";
	protected static final String DEFAULT_SELENIUM_PORT = "4444";
	protected static final String DEFAULT_SHOT_PATH = "D:\\testError\\";
	protected static final String DEFAULT_WAIT_TIME = "3000";
	protected static final String DEFAULT_PAUSE_TIME = "500";

	protected static final String PROPERTY_URL_NAME = "selenium.url";
	protected static final String PROPERTY_BROWSER_NAME = "selenium.browser";
	protected static final String PROPERTY_SELENIUM_HOST_NAME = "selenium.host";
	protected static final String PROPERTY_SELENIUM_PORT_NAME = "selenium.port";
	protected static final String PROPERTY_SHOT_PATH = "selenium.error.shotpath";
	protected static final String PROPERTY_WAIT_TIME = "selenium.waitTime";
	protected static final String PROPERTY_PAUSE_TIME = "selenium.pauseTime";

	/** selenium. */
	protected Selenium selenium;

	/** 画面ajax事件需要等待的时间. */
	private  String waitTime;
	/** 画面动作需要停止的时间. */
	private  String pauseTime;
	/** 测试失败抓图的地址. */
	private  String errorShotPath;

	/**
	 * 初始化selenium client. 从application.test.properties中获取selenium连接参数,否则使用默认配置.
	 */
	@BeforeClass
	public void startSelenium() throws Exception {
		// 通过配置文件设定Selenium初始值，没有在配置文件里设定的用默认值
		Properties p = PropertiesLoaderUtils.loadAllProperties(PROPERTY_FILE);
		String browser = p.getProperty(PROPERTY_BROWSER_NAME, DEFAULT_BROWSER);
		String url = p.getProperty(PROPERTY_URL_NAME, DEFAULT_URL);
		String host = p.getProperty(PROPERTY_SELENIUM_HOST_NAME, DEFAULT_SELENIUM_HOST);
		int port = Integer.valueOf(p.getProperty(PROPERTY_SELENIUM_PORT_NAME, DEFAULT_SELENIUM_PORT));
		errorShotPath = p.getProperty(PROPERTY_SHOT_PATH, DEFAULT_SHOT_PATH);
		waitTime = p.getProperty(PROPERTY_WAIT_TIME, DEFAULT_WAIT_TIME);
		pauseTime = p.getProperty(PROPERTY_PAUSE_TIME, DEFAULT_PAUSE_TIME);

		selenium = new DefaultSelenium(host, port, browser, url);
		selenium.start();
		selenium.windowFocus();
		selenium.windowMaximize();
	}

	/**
	 * 关闭selenium变量.
	 */
	@AfterClass
	public void stopSelenium() throws Exception {
		selenium.close();
		selenium.stop();
	}

	/**
	 * 取得测试失败时截图的路径.
	 * 
	 * @return 失败时截图路径
	 */
	public String getErrorShotPath() {
		return errorShotPath;
	}

	/**
	 * 模拟登录画面运行.
	 */
	public void login(String userId, String password) throws Exception {
		selenium.open("/YDSWEB/");
		selenium.type("userid", userId);
		selenium.type("password", password);
		selenium.click("//input[@type='image']");
		selenium.waitForPageToLoad("5000");
		assertFalse("用户名或密码错误", selenium.getBodyText().contains("用户名或密码错误"));
	}

	/**
	 * 取得Selenium变量.
	 */
	public Selenium getSelenium() {
		return selenium;
	}

	/** Like JUnit's Assert.assertEquals, but knows how to compare string arrays */
	public static void assertEquals(Object s1, Object s2) {
		if (s1 instanceof String && s2 instanceof String) {
			assertEquals((String) s1, (String) s2);
		} else if (s1 instanceof String && s2 instanceof String[]) {
			assertEquals((String) s1, (String[]) s2);
		} else if (s1 instanceof String && s2 instanceof Number) {
			assertEquals((String) s1, ((Number) s2).toString());
		} else {
			if (s1 instanceof String[] && s2 instanceof String[]) {

				String[] sa1 = (String[]) s1;
				String[] sa2 = (String[]) s2;
				if (sa1.length != sa2.length) {
					throw new Error("Expected " + Arrays.toString(sa1) + " but saw " + Arrays.toString(sa2));
				}
				for (int j = 0; j < sa1.length; j++) {
					assertEquals(sa1[j], sa2[j]);
				}
			}
		}
	}

	/**
	 * Like JUnit's Assert.assertEquals, but handles "regexp:" strings like HTML Selenese
	 */
	public static void assertEquals(String s1, String s2) {
		assertTrue("Expected \"" + s1 + "\" but saw \"" + s2 + "\" instead", seleniumEquals(s1, s2));
	}

	/**
	 * Like JUnit's Assert.assertEquals, but joins the string array with commas, and handles "regexp:" strings
	 * like HTML Selenese.
	 */
	public static void assertEquals(String s1, String[] s2) {
		assertEquals(s1, join(s2, ','));
	}

	/**
	 * Compares two strings, but handles "regexp:" strings like HTML Selenese.
	 * 
	 * @param expectedPattern
	 * @param actual
	 * @return true if actual matches the expectedPattern, or false otherwise
	 */
	public static boolean seleniumEquals(String expectedPattern, String actual) {
		if (actual.startsWith("regexp:") || actual.startsWith("regex:") || actual.startsWith("regexpi:")
				|| actual.startsWith("regexi:")) {
			// swap 'em
			String tmp = actual;
			actual = expectedPattern;
			expectedPattern = tmp;
		}
		Boolean b;
		b = handleRegex("regexp:", expectedPattern, actual, 0);
		if (b != null) {
			return b.booleanValue();
		}
		b = handleRegex("regex:", expectedPattern, actual, 0);
		if (b != null) {
			return b.booleanValue();
		}
		b = handleRegex("regexpi:", expectedPattern, actual, Pattern.CASE_INSENSITIVE);
		if (b != null) {
			return b.booleanValue();
		}
		b = handleRegex("regexi:", expectedPattern, actual, Pattern.CASE_INSENSITIVE);
		if (b != null) {
			return b.booleanValue();
		}

		if (expectedPattern.startsWith("exact:")) {
			String expectedExact = expectedPattern.replaceFirst("exact:", "");
			if (!expectedExact.equals(actual)) {
				System.out.println("expected " + actual + " to match " + expectedPattern);
				return false;
			}
			return true;
		}

		String expectedGlob = expectedPattern.replaceFirst("glob:", "");
		expectedGlob = expectedGlob.replaceAll("([\\]\\[\\\\{\\}$\\(\\)\\|\\^\\+.])", "\\\\$1");

		expectedGlob = expectedGlob.replaceAll("\\*", ".*");
		expectedGlob = expectedGlob.replaceAll("\\?", ".");
		if (!Pattern.compile(expectedGlob, Pattern.DOTALL).matcher(actual).matches()) {
			System.out.println("expected \"" + actual + "\" to match glob \"" + expectedPattern
					+ "\" (had transformed the glob into regexp \"" + expectedGlob + "\"");
			return false;
		}
		return true;
	}

	private static Boolean handleRegex(String prefix, String expectedPattern, String actual, int flags) {
		if (expectedPattern.startsWith(prefix)) {
			String expectedRegEx = expectedPattern.replaceFirst(prefix, ".*") + ".*";
			Pattern p = Pattern.compile(expectedRegEx, flags);
			if (!p.matcher(actual).matches()) {
				System.out.println("expected " + actual + " to match regexp " + expectedPattern);
				return Boolean.FALSE;
			}
			return Boolean.TRUE;
		}
		return null;
	}

	/**
	 * Compares two objects, but handles "regexp:" strings like HTML Selenese.
	 * 
	 * @see #seleniumEquals(String, String)
	 * @return true if actual matches the expectedPattern, or false otherwise
	 */
	public static boolean seleniumEquals(Object expected, Object actual) {
		if (expected instanceof String && actual instanceof String) {
			return seleniumEquals((String) expected, (String) actual);
		}
		return expected.equals(actual);
	}

	/** Asserts that two string arrays have identical string contents. */
	public static void assertEquals(String[] s1, String[] s2) {
		String comparisonDumpIfNotEqual = verifyEqualsAndReturnComparisonDumpIfNot(s1, s2);
		if (comparisonDumpIfNotEqual != null) {
			throw new AssertionError(comparisonDumpIfNotEqual);
		}
	}

	/** Asserts that two objects are not the same (compares using .equals()). */
	public static void assertNotEquals(Object obj1, Object obj2) {
		if (obj1.equals(obj2)) {
			fail("did not expect values to be equal (" + obj1.toString() + ")");
		}
	}

	public static void fail(String message) {
		throw new AssertionError(message);
	}

	public static void assertTrue(String message, boolean condition) {
		if (!condition) {
			fail(message);
		}
	}

	public static void assertTrue(boolean condition) {
		assertTrue(null, condition);
	}

	public static void assertFalse(String message, boolean condition) {
		assertTrue(message, !condition);
	}

	public static void assertFalse(boolean condition) {
		assertTrue(null, !condition);
	}

	/** Asserts that two booleans are not the same. */
	public static void assertNotEquals(boolean b1, boolean b2) {
		assertNotEquals(Boolean.valueOf(b1), Boolean.valueOf(b2));
	}

	/**
	 * 动作停止一段时间，时间由配置文件设定，默认为500ms.
	 * 
	 * @param script
	 */
	public void pause() throws Exception {
		Thread.sleep(Integer.parseInt(pauseTime));
	}

	/**
	 * 等待一个script运行，直到script为真继续运行，否则超过waitTime时间，抛出timeout错误 timeout时间在配置文件里设置，默认为3000ms.
	 * 
	 * @param script
	 */
	public void waitForCondition(String script) throws Exception {
		selenium.waitForCondition(script, waitTime);
	}

	private static String verifyEqualsAndReturnComparisonDumpIfNot(String[] s1, String[] s2) {
		boolean misMatch = false;
		if (s1.length != s2.length) {
			misMatch = true;
		}
		for (int j = 0; j < s1.length; j++) {
			if (!seleniumEquals(s1[j], s2[j])) {
				misMatch = true;
				break;
			}
		}
		if (misMatch) {
			return "Expected " + stringArrayToString(s1) + " but saw " + stringArrayToString(s2);
		}
		return null;
	}

	private static String stringArrayToString(String[] sa) {
		StringBuffer sb = new StringBuffer("{");
		for (String element : sa) {
			sb.append(" ").append("\"").append(element).append("\"");
		}
		sb.append(" }");
		return sb.toString();
	}

	public static String join(String[] sa, char c) {
		StringBuffer sb = new StringBuffer();
		for (int j = 0; j < sa.length; j++) {
			sb.append(sa[j]);
			if (j < sa.length - 1) {
				sb.append(c);
			}
		}
		return sb.toString();
	}
}
