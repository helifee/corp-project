/*
 * @(#)BeanAssert.java
 * Copyright (c) 2009-2010 大连远东计算机系统有限公司
 * All rights reserved.
 *      Project: 远东公司内部网
 *    SubSystem: 共通测试系统
 */
package com.yds.base.test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;

import java.beans.BeanInfo;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Method;
import java.util.List;

import org.unitils.reflectionassert.ReflectionAssert;
import org.unitils.reflectionassert.ReflectionComparatorMode;

/**
 * Bean是否相等断言。
 * 
 * @author tianjian
 * @version 1.00 2010/04/02
 */
public class BeanAssert {

	/**
	 * 宽松断言两个Bean对象包含数据是否相同.<br>
	 * 宽松的意思是:对于比较的属性, 只有设置了值才参与比较, 否则忽略(默认值不比较)<br>
	 * 比如用户对象有firest, last name,city信息, 但是我只想对first字段进行比较.则可以这样写:<br>
	 * <code>User actualUser   = new User("John", "Doe", "dalian");
	 * 		 User expectedUser = new User("John",  null,  null);
	 * 		 assertBeanLenientEquals(expectedUser, actualUser);
	 * </code> 这个断言能够成功，但是这种比较必须有一个前提, 就是必须将expect放在前(有null的), actual放在后
	 * 
	 * @param expects 预期对象Bean.
	 * @param actuals 实际对象Bean.
	 */
	@SuppressWarnings("unchecked")
	public static void assertBeanLenientEquals(Object expects, Object actuals) throws Exception {
		if (null != actuals && null != expects && !expects.getClass().equals(actuals.getClass())) {
			throw new Exception("传入的预期对象Bean和Bean不是同一个类型");
		}
		
		// 如果比较对象是List，需要判断List件数是否相等
		if (actuals instanceof List) {
			// 预期数据和实际数据件数是否相等
			assertEquals("期望的数据件数", ((List) expects).size(), ((List) actuals).size());
		}
		// assertLenientEquals作用相当于assertReflectionEquals中忽略顺序和忽略默认值
		ReflectionAssert.assertLenientEquals(expects, actuals);
	}

	/**
	 * 断言两个Bean对象包含数据时候相同.
	 * 
	 * @param expects 预期对象Bean.
	 * @param actuals 实际对象Bean.
	 */
	public static void assertBeanEquals(Object expects, Object actuals) throws Exception {
		assertBeanEquals(expects, actuals, new ReflectionComparatorMode[0]);
	}

	/**
	 * 断言两个Bean对象包含数据时候相同.
	 * 
	 * @param <E>
	 * 
	 * @param expects 预期对象Bean.
	 * @param actuals 实际对象Bean.
	 * @param modes 宽松处理模式.<br>
	 *            宽松(lenient)断言:<br>
	 *            LENIENT_ORDER 忽略集合中顺序问题;<br>
	 *            IGNORE_DEFAULTS 当期盼数据中的某个属性为Java默认值null,0,false时，这个属性不比较;<br>
	 *            LENIENT_DATES 当两个日期都是值，或者都是null的时候，实际的日期将会被忽略.
	 */
	@SuppressWarnings("unchecked")
	public static <E> void assertBeanEquals(Object expects, Object actuals, ReflectionComparatorMode... modes)
			throws Exception {
		if (null != actuals && null != expects && !expects.getClass().equals(actuals.getClass())) {
			throw new Exception("传入的预期对象Bean和Bean不是同一个类型");
		}
		// 如果比较对象是List，需要判断List件数是否相等
		if (actuals instanceof List) {
			// 预期数据和实际数据件数是否相等
			assertEquals("期望的数据件数", ((List<E>) expects).size(), ((List<E>) actuals).size());
		}

		if (0 == modes.length) {
			ReflectionAssert.assertReflectionEquals(expects, actuals);
		} else {
			ReflectionAssert.assertReflectionEquals(expects, actuals, modes);
		}
	}

	/**
	 * 断言两个Bean对象包含数据时候相同.
	 * 
	 * @param expects 预期对象Bean.
	 * @param actuals 实际对象Bean.
	 * @param rowNum List里数据行数.
	 * @param exPropertyList 不需要比较的属性List.
	 * @see {@link #assertListLenientEquals(List, List)} 代替的方法 
	 */
	@Deprecated
	public static void assertBeanEquals(Object expects, Object actuals, int rowNum, List<String> exPropertyList)
			throws Exception {
		// 实际对象不能为Null
		assertNotNull("实际对象为Null", actuals);
		if (!expects.getClass().equals(actuals.getClass())) {
			throw new Exception("传入的预期对象Bean和Bean不是同一个类型");
		}
		// 内省机制得到传入的两个Bean信息
		BeanInfo expectsBi = Introspector.getBeanInfo(expects.getClass(), Object.class);
		BeanInfo actualsBi = Introspector.getBeanInfo(expects.getClass(), Object.class);
		PropertyDescriptor[] expectsprops = expectsBi.getPropertyDescriptors();
		PropertyDescriptor[] actualsprprops = actualsBi.getPropertyDescriptors();

		for (int i = 0; i < expectsprops.length; i++) {
			Method em = expectsprops[i].getReadMethod();
			Method ea = actualsprprops[i].getReadMethod();

			// Bean不是包含在List的时候
			String assertMsg = expectsprops[i].getDisplayName();
			if (-1 != rowNum) {
				assertMsg = "List row number:<" + rowNum + "> " + assertMsg;
			}
			// 需要比较的属性，进行断言
			if (null != exPropertyList) {
				if (!exPropertyList.contains(expectsprops[i].getDisplayName())) {
					assertEquals(assertMsg, em.invoke(expects), ea.invoke(actuals));
				}
			} else {
				assertEquals(assertMsg, em.invoke(expects), ea.invoke(actuals));
			}

		}
	}

	/**
	 * 宽松断言两个List对象包含数据时候相同.
	 * 
	 * @param <E>
	 * @param expectList 预期对象List.
	 * @param actualList 实际对象List.
	 */
	public static <E> void assertListLenientEquals(List<E> expectList, List<E> actualList) throws Exception {
		// List中数据是否相等
		assertBeanLenientEquals(expectList, actualList);
	}

	/**
	 * 断言两个List对象包含数据时候相同.
	 * 
	 * @param <E>
	 * @param expectList 预期对象List.
	 * @param actualList 实际对象List.
	 */
	public static <E> void assertListEquals(List<E> expectList, List<E> actualList) throws Exception {

		// List中数据是否相等
		assertBeanEquals(expectList, actualList);
	}

	/**
	 * 自定义宽松断言两个List对象包含数据时候相同.
	 * 
	 * @param <E>
	 * @param expectList 预期对象List.
	 * @param actualList 实际对象List.
	 * @param modes 宽松处理模式.
	 */
	public static <E> void assertListEquals(List<E> expectList, List<E> actualList, ReflectionComparatorMode... modes)
			throws Exception {

		// List中数据是否相等
		assertBeanEquals(expectList, actualList, modes);
	}

}
