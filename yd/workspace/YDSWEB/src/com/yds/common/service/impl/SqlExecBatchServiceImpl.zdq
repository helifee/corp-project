/*
 * @(#)SqlExecBatchServiceImpl.java
 * Copyright (c) 2009-2010 大连远东计算机系统有限公司
 * All rights reserved.
 *      Project: 远东公司内部网
 *    SubSystem: 共通系统
 */
package com.yds.common.service.impl;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.dao.DataAccessException;
import org.springframework.stereotype.Service;
import com.yds.base.service.AbstractBaseService;
import com.yds.batch.service.BatchJobRun;
import com.yds.common.dao.SqlExecBatchDao;
import com.yds.common.service.SqlExecBatchService;

/**
 * 执行SQL信息插入处理BATCH（数据库操作）.
 * 
 * @author mengxiaoyan
 * @version 1.00 2010/06/05
 */
/**
 * @see SqlExecBatchService,BatchJobRun
 */
@Service("sqlExecBatchServiceImpl")
public class SqlExecBatchServiceImpl extends AbstractBaseService implements
		SqlExecBatchService, BatchJobRun {
	private static final Log LOG = LogFactory.getLog(SqlExecBatchServiceImpl.class);
	private SqlExecBatchDao sqlExecBatchDao;
	private String sqlPath;

	/**
	 * {@inheritDoc}
	 * @throws Exception 
	 */
	@Override
	public void insertSqlExect() throws Exception {
		try {
			// Sql文存放路径
			String path = propMgr.getParameter("yds.log.sqllog.folder")
					+ propMgr.getParameter("yds.log.sqllog.file");
			if (null == getSqlPath() || "".equals(getSqlPath())) {
				setSqlPath(path);
			}
			// 读sql句并且执行
			if (0 == readSqlFileToBuffer(getSqlPath())){
				deleteFile(getSqlPath());				
			}else{
				renameFile(getSqlPath());				
			}

		} catch (Exception e) {
			e.printStackTrace();	
			throw new Exception(e);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void jobRun() throws Throwable {
		insertSqlExect();
	}

	/**
	 * {@inheritDoc}
	 */
	public void setSqlExecBatchDao(SqlExecBatchDao dao) {
		sqlExecBatchDao = dao;
	}

	/**
	 * {@inheritDoc}
	 */
	public String getSqlPath() {
		return sqlPath;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setSqlPath(String sqlPath) {
		this.sqlPath = sqlPath;
	}

	/**
	 * @param sqlPath
	 * 
	 *            读取sql文并执行
	 */
	private Integer readSqlFileToBuffer(String sqlPath)throws Exception {
		Integer sqlErrFlg = 0;
		LOG.debug("sql文件路径： " + sqlPath);
		InputStreamReader read = null;
		BufferedReader reader = null;
		try {
			read = new InputStreamReader(
					new FileInputStream(new File(sqlPath)), "UTF-8");
			reader = new BufferedReader(read);
			String line = "";
			String tempLine = "";
			// 读取一行
			while ((line = reader.readLine()) != null) {
				try {						
					if (!"".equals(line)) {
						if (!"-- ".equals(line.substring(0, 3))){
							if("');".equals(line.substring(line.length()-3))){
								tempLine = tempLine + line;
								// 执行一行						
								sqlExecBatchDao.execSql(tempLine);
								tempLine = "";
							}else{
								tempLine = tempLine + line;							
							}
						}
					}
				}catch(DataAccessException e){
					e.printStackTrace();
					sqlErrFlg = 1;
					tempLine = "";					
				}				
			}
		} catch (UnsupportedEncodingException e) {
			throw new Exception(e);
		} catch (FileNotFoundException e) {
			throw new Exception(e);
		} catch (IOException e) {
			throw new Exception(e);
		} catch (Exception e) {
			throw new Exception(e);
		} finally {
			if (null != read) {
				try {
					read.close();
				} catch (IOException e) {
					throw new Exception(e);
				} finally {
					reader.close();
				}
			}
			if (null != reader) {
				try {
					reader.close();
				} catch (IOException e) {
					throw new Exception(e);
				}
			}
		}			
		return sqlErrFlg;
	}

	/**
	 * 删除已经读取过的sql文件
	 * 
	 * @param sqlPath
	 *            sql文件路径
	 */	
	private void deleteFile(String fileName) throws Exception{
		File file = new File(fileName);
		if(! file.delete()){
			throw new Exception("文件删除有误！");
		}
	}

	/**
	 * 重命名已经读取过的sql文件
	 * 
	 * @param sqlPath
	 *            sql文件路径
	 */
	private void renameFile(String fileName) throws Exception{
		File file = new File(fileName);
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat( "yyyy-MM-dd");		
		if(! file.renameTo(new File(file.getParentFile() 
				 + "\\log_"
				 + simpleDateFormat.format(Calendar.getInstance().getTime()) 
				 + ".sql"))){
			throw new Exception("文件重命名有误！");
		}
	}
}
