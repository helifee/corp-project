/*
 * @(#)TreeUtil.java
 * Copyright (c) 2009-2010 大连远东计算机系统有限公司
 * All rights reserved.
 *      Project: 远东公司内部网
 *    SubSystem: 共通系统
 */

package com.yds.util.service;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

import net.sf.json.JSONArray;
import net.sf.json.JSONObject;

import com.yds.att.bean.TreeLevel;
import com.yds.common.bean.Node;
import com.yds.common.bean.Tree;

/**
 * 获取树所需的struct
 * 
 * @author zhangdaoqiang,sun
 * @version 1.0 2010/02/05
 */
public class TreeUtil {
	
	//常量定义
	private static final int    DEFAULT_UNIT_LENGTH = 2;
	
	/**
	 * 将从DB中取得的List转换为Ttree, 显示顺序的单位长度默认为两位
	 * 
	 * @param nodes 从DB取得的List
	 * @return
	 */
	public static Tree getTree(List<Node> nodes) {
		return getTree(nodes, TreeUtil.DEFAULT_UNIT_LENGTH);
	}

	/**
	 * 将List<Node>转换为List<Tree>, 显示顺序的单位长度默认为两位
	 * 
	 * @param nodes 从DB取得的List
	 * @return List<Tree>
	 */
	public static List<Tree> getTreeList(List<Node> nodes) {
		return getTreeList(nodes, TreeUtil.DEFAULT_UNIT_LENGTH);
	}
	
	/**
	 * 将List<Node>转换为List<Tree>
	 * 
	 * @param nodes 从DB取得的List
	 * @param DEFAULT_UNIT_LENGTH 显示顺序的单位长度
	 * @return List<Tree>
	 */
	public static List<Tree> getTreeList(List<Node> nodes, int unitLength) {
		return getTree(nodes,unitLength).getItems();
	}

	/**
	 * 将从DB中取得的List转换为Tree
	 * 
	 * @param nodeList 从DB取得的List
	 * @param DEFAULT_UNIT_LENGTH 显示顺序的单位长度
	 * @return Tree
	 */
	public static Tree getTree(List<Node> nodeList, int unitLength) {
		//设定虚拟根节点
		if(null == nodeList || nodeList.size()==0 || null == nodeList.get(0).getDispSeq() || "".equals(nodeList.get(0).getDispSeq())) return new Tree();
		Node n = new Node();
		n.setDispSeq(StringUtil.getUnit(nodeList.get(0).getDispSeq().length(), "9"));
		nodeList.add(0,n);
		// 结束标志
		String endStr =  StringUtil.getUnit(unitLength);
		Stack<Tree> s = new Stack<Tree>();
		for(Node node : nodeList){
			while (true) {

				//把node中的值传到Tree中
				Tree t = new Tree();
				t.setId(node.getId());
				t.setTxt(node.getTxt());
				if(null != node.getUrl()) {
					t.setTxt("<a href='" + node.getUrl() + "'>" + node.getTxt() + "</a>");
				} else {
					t.setTxt(node.getTxt());
				}
				
				t.setCheck(node.getCheck());
				t.setDispSeq(StringUtil.trimUnit(node.getDispSeq(), endStr, 1));
				t.setItems(new ArrayList<Tree>());
				
				if(s.empty()){
					s.push(t);
					break;
				}else if(s.size()==1 || (node.getDispSeq().startsWith(s.peek().getDispSeq()))){
					s.peek().getItems().add(t);
					s.push(t);
					break;
				}else{
					s.pop();
				}
			}
		}
		return s.get(0);
	}

	/**
	 * 将json类型的tree转成List<Node>, 显示顺序字符串单位长度默认2位
	 * 
	 * @param tree json类型的tree结构
	 * @param maxLength 指定生成record中显示结点顺序字符串的最大长度
	 */
	public static List<Node> getNodes(JSONObject tree, int maxLength) {
		return treeConverter(tree, null, null, 0, maxLength, TreeUtil.DEFAULT_UNIT_LENGTH);
	}
	
	/**
	 * 将json类型的tree转成List<Node>
	 * 
	 * @param tree json类型的tree结构
	 * @param maxLength 指定生成record中显示结点顺序字符串的最大长度
	 * @param DEFAULT_UNIT_LENGTH 显示顺序字符串单位长度
	 * @return
	 */
	public static List<Node> getNodes(JSONObject tree, int maxLength, int unitLength) {
		return treeConverter(tree, null, null, 0, maxLength, unitLength);
	}
	
	/**
	 * 将json类型的tree转成List<Node>
	 * 
	 * @param records 存放结点的List
	 * @param tree 待转化的json类型的tree
	 * @param parentSeq 父结点的显示顺序字符串
	 * @param index 此结点在兄弟结点中的位置
	 * @param maxLength 显示顺序字符串的最大长度
	 * @param DEFAULT_UNIT_LENGTH 显示顺序的单位长度
	 */
	private static List<Node> treeConverter(JSONObject tree, List<Node> list, String parentSeq, int index, int maxLength, int unitLength) {

		// TODO 建议用反射实现
		//转化当前结点并存入List中
		List<Node> nodes;
		
		//递归开始时初始化一个records,递归调用时为上一层传过来的list
		if(null == list) {
			nodes = new ArrayList<Node>();
		} else {
			nodes = list;
		}
		Node r = new Node();
		r.setId(tree.getString("id"));
		r.setTxt(tree.getString("txt"));
		r.setCheck(Integer.parseInt(tree.getString("check")));
		String seq = getSeq(parentSeq, index, maxLength, unitLength);
		r.setDispSeq(seq);
		nodes.add(r);
		
		//遍历子结点集
		JSONArray items = tree.getJSONArray("items");
		if(null != items) {
			for(int i = 0; i < items.size(); i++) {
				nodes = treeConverter((JSONObject)items.get(i), nodes, seq, i, maxLength, unitLength);
			}
		}
		
		return nodes;
	}
	
	/**
	 * 取得当前结点的显示顺序
	 * 
	 * @param parent 父结点的显示顺序字符串
	 * @param index 此结点在兄弟结点中的位置
	 * @param maxLength 显示顺序字符串的最大长度
	 * @param DEFAULT_UNIT_LENGTH 显示顺序的单位长度
	 * @return 当前结点的显示顺序
	 */
	private static String getSeq(String parentSeq, int index, int maxLength, int unitLength) {
		
		//取得根结点的显示顺序
		if(null == parentSeq) {
			return StringUtil.getUnit(maxLength);
		}
		StringBuffer seq = new StringBuffer();
		
		//补全单位字符串，不足前面加0
		String last = String.valueOf(index + 1);
		int len = last.length();
		if(len < unitLength) {
			last = StringUtil.getUnit(unitLength - len) + last;
		}
		
		//取得显示顺序的有效字符串
		int beginIndex = 0;
		int endIndex = unitLength;
		String unit = parentSeq.substring(beginIndex, endIndex);
		while(!StringUtil.getUnit(unitLength).equals(unit)) {
			beginIndex += unitLength;
			endIndex += unitLength;
			unit = parentSeq.substring(beginIndex, endIndex);
		}
		String effect = parentSeq.substring(0, endIndex - unitLength);
		seq.append(effect).append(last);
		
		//显示顺序不足最大位数的在后面用0补足
		int length = seq.length();
		if(length < maxLength) {
			for(int i = 0; i < maxLength - length; i++) {
				seq.append(StringUtil.getUnit(1));
			}
		}
		
		return seq.toString();
	}
	
	/**
	 * 取得指定的树结点集合中的叶子结点
	 * 
	 * @param nodes ： 树结点集合
	 * @param bitNum ： 结点层级的单位位数（即用多少位表示一个层级）
	 * @return List : 叶子结点集合
	 */
	public static <T extends TreeLevel> List<T> getLeafs(List<T> nodes, int bitNum) {
		
		if(null == nodes || nodes.size() == 0) {
			return null;
		}
		
		List<T> ret = new ArrayList<T>();
		
		String unitStr = StringUtil.getUnit(bitNum);
		for(int i=1; i<nodes.size(); i++) {
			T preNode = nodes.get(i - 1);
			T curNode = nodes.get(i);
			String preLevel = StringUtil.rTrim(preNode.getLevel(), unitStr);
			String curLevel = StringUtil.rTrim(curNode.getLevel(), unitStr);
			
			if(!curLevel.startsWith(preLevel)) {
				ret.add(preNode);
			}
		}
		
		ret.add(nodes.get(nodes.size() - 1));
		
		return ret;
	}
	
	/**
	 * 
	 * @param nodes : 树结点集合
	 * @param leaf : 指定的叶子结点
	 * @param bitNum : 结点层级的单位位数（即用多少位表示一个层级）
	 * @return List : 
	 */
	public static <T extends TreeLevel> List<T> getBranches(List<T> nodes, T leaf, int bitNum) {
		List<T> ret = new ArrayList<T>();
		ret.add(leaf);
		
		String unitStr = StringUtil.getUnit(bitNum);
		String leafLevel = StringUtil.rTrim(leaf.getLevel(), unitStr);
		int parentCount = leafLevel.length() / bitNum - 1;
		
		for(int i=parentCount; i>0; i--) {
			String parentLevel = leafLevel.substring(0, i * bitNum);
			for(int j=0; j<nodes.size(); j++) {
				T node = nodes.get(j);
				if(parentLevel.equals(StringUtil.rTrim(node.getLevel(), unitStr))) {
					ret.add(node);
					break;
				}
			}
			
		}
		
		return ret;
	}
}
