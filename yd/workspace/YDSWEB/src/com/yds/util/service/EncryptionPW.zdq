/**
 * 密码MD5加密
 */
package com.yds.util.service;

public class EncryptionPW {
	
	public static final String mdStr = "www.ysys.com.cn";		

	//MD5加密 （新系统加密方式用）
	public static String md5(String originalPW,String userId) {
		  String mdPw="";
          originalPW = mdStr + userId + mdStr + originalPW;
		  char hexDigits[] = {// 用来将字节转换成 16 进制表示的字符
		     '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd',  'e', 'f'}; 
		   try
		   {
		    java.security.MessageDigest md = java.security.MessageDigest.getInstance( "MD5" );
		    md.update( originalPW.getBytes() );
		    byte tmp[] = md.digest();          // MD5 的计算结果是一个 128 位的长整数，
		                                                // 用字节表示就是 16 个字节
		    char str[] = new char[16 * 2];   // 每个字节用 16 进制表示的话，使用两个字符，
		                                                 // 所以表示成 16 进制需要 32 个字符
		    int k = 0;                                // 表示转换结果中对应的字符位置
		    for (int i = 0; i < 16; i++) {          // 从第一个字节开始，对 MD5 的每一个字节
		                                                 // 转换成 16 进制字符的转换
		     byte byte0 = tmp[i];                 // 取第 i 个字节
		     str[k++] = hexDigits[byte0 >>> 4 & 0xf];  // 取字节中高 4 位的数字转换, 
		                                                             // >>> 为逻辑右移，将符号位一起右移
		     str[k++] = hexDigits[byte0 & 0xf];            // 取字节中低 4 位的数字转换
		    } 
		    mdPw = new String(str);                                 // 换后的结果转换为字符串

		   }catch( Exception e )
		   {
		    e.printStackTrace();
		   }
		   return mdPw;
		 }

	// 口令加密 王铎 2009/09/17做成（旧系统加密方式用）
	// 用法： Encryption e = new Encryption();
	// System.out.println(e.getEncryption("!@#wang!"));
	public static String getEncryption(String password, String userid) {

		if (password == null)
			return null;
		if (password.trim().equals(""))
			return "";

		byte[] tempByte = password.getBytes();
		byte[] tempByte2 = userid.getBytes();

		double sum = 0;

		for (int i = 0; i < tempByte.length; i++) {

			int num = tempByte[i];
			if (i < tempByte2.length)
				num = num + tempByte2[i];
			if (num < 100) {
				num = num + 100;
			}
			sum += Math.pow(num, 1.8 + (i - i % 10) / 10f);

		}

		sum = Math.pow(sum, 0.8);

		String tempStr = my_replace(Double.toString(sum), ".", "");

		tempStr = hexString2binaryString(tempStr);

		int len = tempStr.length() < 88 ? tempStr.length() : 88;

		tempStr = XOR(tempStr.substring(0, 44), tempStr.substring(44, len));
		tempStr = binaryString2hexString(tempStr);

		return tempStr;

	}

	// 16进制转2进制
	private static String hexString2binaryString(String hexString) {
		if (hexString == null)
			return null;
		String tmp;
		StringBuffer bs = new StringBuffer("");
		for (int i = 0; i < hexString.length(); i++) {
			tmp = "0000" + Integer.toBinaryString(Integer.parseInt(hexString.substring(i, i + 1), 16));
			bs.append(tmp.substring(tmp.length() - 4));
		}
		return bs.toString();
	}

	// 2进制转16进制
	private static String binaryString2hexString(String bString) {
		if (bString == null)
			return null;
		StringBuffer tmp = new StringBuffer();
		int iTmp = 0;
		for (int i = 0; i < bString.length(); i += 4) {
			iTmp = 0;
			for (int j = 0; j < 4; j++) {
				iTmp += Integer.parseInt(bString.substring(i + j, i + j + 1)) << (4 - j - 1);
			}
			tmp.append(Integer.toHexString(iTmp));
		}
		return tmp.toString();
	}

	// 节位异或
	private static String XOR(String arg1, String arg2) {

		String arg = "";
		StringBuffer sb = new StringBuffer();

		int len = 0;

		if (arg1.length() > arg2.length()) {
			arg = arg1;
			len = arg2.length();
		} else {
			arg = arg2;
			len = arg1.length();
		}

		for (int i = 0; i < len - 1; i++) {
			String temp1 = arg1.substring(i, i + 1);
			String temp2 = arg2.substring(i, i + 1);
			sb.append(temp1.equals(temp2) ? "1" : "0");
		}

		sb.append(arg.substring(len - 1));

		return sb.toString();
	}
	
	// 字符替换（旧系统加密方式用）
	private static String my_replace(String strInfo, String strSearch, String strReplace) {
		// 在strInfo中，把strSearch替换成strReplace
		int size = 0;
		int index = -1;
		String result = "";
		do {
			size++;
			index++;
			index = strInfo.indexOf(strSearch, index);
		} while (index != -1);
		String[] arrRtn = new String[size];
		// ==========================================================
		int startIndex = 0;
		int endIndex = 0;
		for (int i = 0; i < size; i++) {
			endIndex = strInfo.indexOf(strSearch, startIndex);
			if (endIndex == -1) {

				arrRtn[i] = strInfo.substring(startIndex);
			} else {
				arrRtn[i] = strInfo.substring(startIndex, endIndex) + strReplace;
			}
			startIndex = endIndex + 1;
			result = result + arrRtn[i];
		}
		return result;
	}

}
