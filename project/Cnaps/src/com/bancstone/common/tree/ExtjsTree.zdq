/**
 * <p>项目名称：zhiNengT<p>
 * <ul>
 * <li>1、版权所有：驰波公司</li>
 * <li>2、开发作者：王亮</li>
 * <li>3、开发日期：Aug 18, 2010</li>
 * <li>4、开发时间：9:59:52 AM</li>
 * <li>5、文件名称：ExtjsTree.java</li>
 * <li>6、包路径名：com.bancstone.common.tree</li>
 * </ul>
 */
package com.bancstone.common.tree;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * <ul>
 * <li>1、开发日期：Aug 18, 2010</li>
 * <li>2、开发时间：9:59:52 AM</li>
 * <li>3、类型名称：ExtjsTree</li>
 * <li>4、类型意图：根据数据库中的权限表生成extjs动态树所需的jsontree字符串.</li>
 * </ul>
 * ExtjsTree类:提供了生成三种Extjs树的字符串. <br>
 * 1:标准的jsontree字符串. <br>
 * 2:生成带有checkbox的树的jsontree字符串.注:权限树的叶子节点是带有checkbox框的具体权限. <br>
 * 3:根据具体的叶子节点权限列表,生成叶子节点的父节点树的jsontree字符串.这个jsontree字符串也就功能Tree列表.
 * 
 * @author 王亮
 * 
 */

public class ExtjsTree {
	/**
	 * 生成jonstree字符串缓存区
	 */
	private StringBuffer returnStr = new StringBuffer();

	/**
	 * 具有权限的叶子树列表
	 */
	private List leafList = new ArrayList();
	/**
	 * 根据叶子节点所生成的菜单树列表
	 */
	private List menuListTree = new ArrayList();

	/**
	 * 生成标准的jsontree列表
	 */
	private List treeList = new ArrayList();

	/**
	 * 是否是带有checkbox的树的标志,当标志树为true时,生成权限树.注:把所有的叶子节点上加上checkbox对话框.
	 */
	private boolean isCheckTree = false;

	private boolean isUrlTree = false;

	/**
	 * 根据这个跟节点生成树.
	 */
	private TreeNode root = null;

	/**
	 * 构造一个标准树或一个权限树的实例.
	 * 
	 * @param root
	 *            TreeNode 树的根节点.根据这个根节点从treeList列表中生成树.
	 * @param treeList
	 *            List 树列表,来自数据库的权限表.
	 */
	public ExtjsTree(TreeNode root, List treeList) {// 构造方法里初始化模拟List
		this.root = root;
		this.treeList = treeList;
	}

	/***************************************************************************
	 * 构造一个根据叶子权限节点列表,生成的树的实例.
	 * 
	 * @param root
	 *            TreeNode 树的根节点.根据这个根节点从treeList列表中生成树.
	 * @param leafList
	 *            List 叶子节点的列表.来自数据库中的权限表.
	 * @param treeList
	 *            List 树列表,来自数据库的权限树表.
	 */
	public ExtjsTree(TreeNode root, List leafList, List treeList) {
		this.root = root;
		this.leafList = leafList;
		this.treeList = treeList;

	}

	/**
	 * 判断该节点是否有子节点
	 * 
	 * @param treeNode
	 * @return 有子节点放回true.
	 */
	public boolean hasChild(TreeNode treeNode) {
		return getChildList(treeNode).size() > 0 ? true : false;
	}

	/**
	 * 获取该节点的子节点列表.
	 * 
	 * @param treeNode
	 * @return 返回子节点列表.
	 */
	public List getChildList(TreeNode treeNode) {
		List li = new ArrayList();
		Iterator it = this.treeList.iterator();
		while (it.hasNext()) {
			TreeNode n = (TreeNode) it.next();
			if (n.getParentId() == treeNode.getId()) {
				li.add(n);
			}
		}
		return li;
	}

	/**
	 * 更具该节点的父节点id 获取父节点对象.
	 * 
	 * @param pid
	 * @return 返回父节点对象.
	 */
	public TreeNode getParentNode(int pid) {
		TreeNode pNode = null;
		Iterator it = this.treeList.iterator();
		while (it.hasNext()) {
			TreeNode n = (TreeNode) it.next();
			if (pid == -1) {
				break;
			}
			if (pid == n.getId()) {
				pNode = n;
				break;
			}
		}
		return pNode;
	}

	/**
	 * 用递归方法计算出该节点的所有子节点.(如果this.isAuthorityTree ==
	 * ture生成权限树字符串,在叶子节点上加上checkbox选项框)
	 * 
	 * @param treeNode
	 */
	public void recursionAllSubNodeFn(TreeNode treeNode) {
		if (hasChild(treeNode)) {
			returnStr.append("{id:");
			returnStr.append(treeNode.getId());
			returnStr.append(",parentId:");
			returnStr.append(treeNode.getParentId());
			returnStr.append(",text:");
			returnStr.append("\"" + treeNode.getText() + "\"");
			returnStr.append(",expanded:" + treeNode.getExpanded());
			returnStr.append(",children:[");
			List childList = getChildList(treeNode);
			Iterator it = childList.iterator();
			while (it.hasNext()) {
				TreeNode n = (TreeNode) it.next();
				recursionAllSubNodeFn(n);
			}
			returnStr.append("]},");
		} else {
			returnStr.append("{id:");
			returnStr.append(treeNode.getId());
			returnStr.append(",parentId:");
			returnStr.append(treeNode.getParentId());
			returnStr.append(",text:");
			returnStr.append("\"" + treeNode.getText() + "\"");
			if (this.isCheckTree && treeNode.getId() != 0) {
				returnStr.append(",checked:");
				returnStr.append(treeNode.getChecked());
			}
			if (this.isUrlTree && treeNode.getId() != 0) {
				returnStr.append(",url:");
				returnStr.append("\"" + treeNode.getUrl() + "\"");
			}
			returnStr.append(",leaf:true},");
		}

	}

	/**
	 * 用递归方法计算出该叶子节点的父节点树.并把这些父节点添加到父节点树中(this.menuTreeList).
	 * 
	 * @param treeNode
	 */
	public void recursionAllPNodeFn(TreeNode treeNode) {
		treeNode = this.getParentNode(treeNode.getParentId());
		if (treeNode == null) {
			return;
		}

		if (this.menuListTree.contains(treeNode)) {
			return;
		}
		this.menuListTree.add(treeNode);
		recursionAllPNodeFn(treeNode);

	}

	/**
	 * 修饰一下才能满足Extjs的Json格式.
	 * 
	 * @param returnStr
	 *            用递归方法生成的jonstree字符串.
	 * @return 返回满足Extjs动态树的Json格式字符串.
	 */
	public String modifyStr(String returnStr) {
		return ("[" + returnStr + "]").replaceAll(",]", "]");

	}

	/**
	 * 根据叶子节点权限列表生成菜单树.
	 * 
	 * @param leafList
	 * @return 返回一个菜单树列表.
	 */
	public List getMenuTreeList(List leafList) {
		Iterator it = leafList.iterator();
		while (it.hasNext()) {
			TreeNode treeNode = (TreeNode) it.next();
			this.recursionAllPNodeFn(treeNode);
		}

		return this.menuListTree;
	}

	/**
	 * 根据数据源生成标准的exjts 动态树字符串.
	 * 
	 * @return 返回标准树字符串.
	 */
	public String toJsonTree() {

		/*
		 * ----测试数据---- Iterator it = this.treeList.iterator(); while
		 * (it.hasNext()) { TreeNode n = (TreeNode) it.next();
		 * System.out.println("nodeid" + n.getId() + " nodepid" +
		 * n.getParentId()); } ----测试数据----
		 */
		this.recursionAllSubNodeFn(this.root);
		return this.modifyStr(this.returnStr.toString());
	}

	/**
	 * 根据数据源生成具有checkbox属性的exjts 动态树字符串.
	 * 
	 * @return 返回带有checkbox属性的树字符串.
	 */
	public String toJsonCheckTree() {
		this.isCheckTree = true;
		return this.toJsonTree();
	}

	/**
	 * 
	 * <ul>
	 * <li>1、开发作者：王亮</li>
	 * <li>2、开发日期：Aug 20, 2010</li>
	 * <li>3、开发时间：2:17:16 PM</li>
	 * <li>4、返回类型：String</li>
	 * <li>5、方法含义：</li>
	 * <li>6、方法说明：根据数据源生成具有连接地址属性url的exjts 动态树字符串.</li>
	 * </ul>
	 * 
	 * @return
	 */
	public String toJsonUrlTree() {
		this.isUrlTree = true;
		return this.toJsonTree();
	}

	/**
	 * 根据数据源和权限列表,生成extjs动态树的权限菜单字符串.
	 * 
	 * @return 返回菜单列表字符串.
	 */
	public String toJsonMenuTree() {
		this.treeList = this.getMenuTreeList(this.leafList);
		this.isCheckTree = false;
		return this.toJsonTree();
	}

}
