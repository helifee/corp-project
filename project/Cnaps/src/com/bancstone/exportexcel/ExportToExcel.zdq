package com.bancstone.exportexcel;

import java.io.FileOutputStream;
import java.math.BigDecimal;
import java.util.Iterator;
import java.util.List;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletResponse;
import org.apache.log4j.Logger;
import org.apache.poi.hssf.usermodel.HSSFCell;
import org.apache.poi.hssf.usermodel.HSSFCellStyle;
import org.apache.poi.hssf.usermodel.HSSFFont;
import org.apache.poi.hssf.usermodel.HSSFRow;
import org.apache.poi.hssf.usermodel.HSSFSheet;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.hssf.util.Region;


public class ExportToExcel { 

	private HSSFWorkbook workbook;
	private HSSFSheet sheet;
	private HSSFRow row;
	private HSSFCell cell;
	private HSSFCellStyle bigBold,smallBold,smallMiddle,smallLeft,smallRight;
	private int j=0;
	protected static final Logger log = Logger.getLogger(ExportToExcel.class);

	
	public ExportToExcel(){
		workbook = new HSSFWorkbook();
		sheet = workbook.createSheet();
		row = sheet.createRow((short) 0);
		cell = row.createCell((short) 0);
		bigBold = getStyle(Constants.bigFontSize,Constants.fontStrong,HSSFCellStyle.ALIGN_CENTER); 
		smallBold = getStyle(Constants.littleFontSize,Constants.fontStrong,HSSFCellStyle.ALIGN_CENTER); 
		smallMiddle = getStyle(Constants.littleFontSize,"",HSSFCellStyle.ALIGN_CENTER);
		smallLeft = getStyle(Constants.littleFontSize,"",HSSFCellStyle.ALIGN_LEFT);
		smallRight = getStyle(Constants.littleFontSize,"",HSSFCellStyle.ALIGN_RIGHT);
	}

	//生成 excel
	//titleType 如果是 1 表示一维表头，2 表示二 维表头，3表示三维表头
	public void exportExcel(String titleType,            //表头类型
			                String [][] names,           //表头值
			                List list,		             //集合
			                HttpServletResponse response,//response
			                String msgtype,
					        String prodate,
					        String pmtsts,
					        BigDecimal dbitdecimal,
			                String fileName){               //文件名
		
	 try {
			j=1;
			row = sheet.createRow((short) (j-1));
			if(titleType.equals("1")){//单表头
				log.debug("单表头文件");
				mergeCell(names.length,msgtype,prodate,pmtsts,fileName);
				createSingleCell(names);
				j=4;
			}else if(titleType.equals("2")){//2 维表头 
				log.debug("2维表头文件");
				mergeCell(getCellSum2(names),msgtype,prodate,pmtsts,fileName);
				createDoubleCell(names);
				j=5;
			}else if(titleType.equals("3")){//3 维表头 
				log.debug("3维表头文件");
				mergeCell(getCellSum3(names),msgtype,prodate,pmtsts,fileName);
				createThirdCell(names);
				j=6;
			}
	
			Iterator it = list.iterator();
			while(it.hasNext()){
				HSSFRow row2 = sheet.createRow((short) (j-1));
				List ll = (List) it.next();
				createTableCell(row2,ll.toArray());
				j++;
			}
			HSSFRow rowd = sheet.createRow((short) (j));
			HSSFCell cell0 = rowd.createCell((short)0);
			createRow(cell0,smallRight);
			cell0.setCellValue("总金额");
			HSSFCell cell1 = rowd.createCell((short)1);
			createRow(cell1,smallRight);
			cell1.setCellValue(SystemContains.parseMoney(SystemContains.PATTERN_MOENY,StringUtil.nullToString(dbitdecimal.toPlainString())));
			HSSFCell cell2 = rowd.createCell((short)2);
			createRow(cell2,smallRight);
			cell2.setCellValue("总笔数");
			HSSFCell cell3 = rowd.createCell((short)3);
			createRow(cell3,smallRight);
			cell3.setCellValue(list.size());
			//是否导出excel.或者直接在内存下载
			ifCreateExcel(workbook,response,fileName,false);
		} catch (Exception e) {
			log.error("导出excel出错："+e);
			e.printStackTrace();
		}
	}
	
 

	//生成 excel
	//titleType 如果是 1 表示一维表头，2 表示二 维表头，3表示三维表头
	public void exportExcel_1(String titleType,            //表头类型
			                String [][] names,           //表头值
			                List list,		             //集合
			                HttpServletResponse response,//response
			                String message,
			                String message1,
					        String message2,
			                String fileName){               //文件名
		
	 try {
			j=1;
			row = sheet.createRow((short) (j-1));
			if(titleType.equals("1")){//单表头
				log.debug("单表头文件");
				mergeCell_1(names.length,message,fileName);
				createSingleCell(names);
				j=4;
			}else if(titleType.equals("2")){//2 维表头 
				log.debug("2维表头文件");
				mergeCell_1(getCellSum2(names),message,fileName);
				createDoubleCell(names);
				j=5;
			}else if(titleType.equals("3")){//3 维表头 
				log.debug("3维表头文件");
				mergeCell_1(getCellSum3(names),message,fileName);
				createThirdCell(names);
				j=6;
			}
	
			Iterator it = list.iterator();
			while(it.hasNext()){
				HSSFRow row2 = sheet.createRow((short) (j-1));
				List ll = (List) it.next();
				createTableCell(row2,ll.toArray());
				j++;
			}
			HSSFRow rowd = sheet.createRow((short) (j));
			HSSFCell cell0 = rowd.createCell((short)0);
			createRow(cell0,smallRight);
			cell0.setCellValue("");
			HSSFCell cell1 = rowd.createCell((short)1);
			createRow(cell1,smallRight);
			cell1.setCellValue(message1);
			HSSFCell cell2 = rowd.createCell((short)2);
			createRow(cell2,smallRight);
			cell2.setCellValue("总笔数");
			HSSFCell cell3 = rowd.createCell((short)3);
			createRow(cell3,smallRight);
			cell3.setCellValue(message2);
			//是否导出excel.或者直接在内存下载
			ifCreateExcel(workbook,response,fileName,false);
		} catch (Exception e) {
			log.error("导出excel出错："+e);
			e.printStackTrace();
		}
	}
	
	//生成 excel,重载了 exportExcel 方法，使之能接受 3 维数组，生成 4 维表头
	public void exportExcel(String titleType,
	                        String [][][] names,
					        List list,
					        HttpServletResponse response,
					        String msgtype,
					        String prodate,
					        String pmtsts,
					        String fileName){
      try{
			j=1;
			row = sheet.createRow((short) (j-1));
			if(titleType.equals("4")){//4 维表头
				log.debug("4维表头文件");
				mergeCell(getCellSum4(names),msgtype,prodate,pmtsts,fileName);
				createFourthCell(names);
				j=7;
			}
			
			Iterator it = list.iterator();
			while(it.hasNext()){
				HSSFRow row2 = sheet.createRow((short) (j-1));
				List ll = (List) it.next();
				createTableCell(row2,ll.toArray());
				j++;
			}
			
			//是否导出excel.或者直接在内存下载
			ifCreateExcel(workbook,response,fileName,false);
		 }catch(Exception e){
			log.error("导出excel出错："+e);
			e.printStackTrace();
		 }
	}

	private String getTitle(String msgtype,String prodate,String pmtsts){
		StringBuffer sb=new StringBuffer();
		sb.append(" "+Constants.msgtype+"："+msgtype);
		sb.append("        "+Constants.prodate+": "+prodate);
		sb.append("        "+Constants.pmtsts+": "+pmtsts+" ");
		return sb.toString();
	}

	//合并 表头
	private void mergeCell(int cellNum,
						    String msgtype,
						    String prodate,
						    String pmtsts,
						    String fileName){
		
		sheet.addMergedRegion(new Region(0, (short) 0, 0,(short)(cellNum-1)));
		cell = row.createCell((short) 0);
		createRow(cell,bigBold);
		cell.setCellValue(fileName);
		row = sheet.createRow((short) 1);//第二行
		sheet.addMergedRegion(new Region(1, (short) 0, 1,(short)(cellNum-1)));
		cell = row.createCell((short) 0);
		createRow(cell,smallBold);
		cell.setCellValue(getTitle(msgtype,prodate,pmtsts));
		row = sheet.createRow((short) 2);//第3行
	}
	//合并 表头
	private void mergeCell_1(int cellNum,
						    String message,
						    String fileName){
		
		sheet.addMergedRegion(new Region(0, (short) 0, 0,(short)(cellNum-1)));
		cell = row.createCell((short) 0);
		createRow(cell,bigBold);
		cell.setCellValue(fileName);
		row = sheet.createRow((short) 1);//第二行
		sheet.addMergedRegion(new Region(1, (short) 0, 1,(short)(cellNum-1)));
		cell = row.createCell((short) 0);
		createRow(cell,smallBold);
		cell.setCellValue(message);
		row = sheet.createRow((short) 2);//第3行
	}
	//得到 2 维表头的单元格数目
	private int getCellSum2(String [][] names){
		int sumTD = 0;
		String [] element = null;
		for(int i=0;i<names.length;i++){
			element = names[i];
			if(element.length==1){
				sumTD++;
			}else{
				Tosplit ts=new Tosplit();
				sumTD = sumTD + ts.Splited(element[1]).length;
			}
		}
		return sumTD;
	}
	
	//得到 3 维表头的单元格数目
	private int getCellSum3(String [][] names){
		int sumTD = 0;
		String [] element = null;
		for(int i=0;i<names.length;i++){
			element = names[i];
			if(element.length==1){
				sumTD++;
			}else{
				sumTD = sumTD + getCellCount(element);
			}
		}
		return sumTD;
	}
	
	//	得到 4 维表头的单元格数目
	private int getCellSum4(String [][][] names){
		int sumTD = 0;
		String [][] element = null;
		for(int i=0;i<names.length;i++){
			element = names[i];
			if(element.length==1){
				sumTD++;
			}else{
				sumTD = sumTD + getCellCountFourth(element);
			}
		}
		return sumTD;
	}
	
	//判断是否导出excel.或者直接在内存下载
	private void ifCreateExcel(HSSFWorkbook webbook,
			                   HttpServletResponse response,
			                   String fileName,
			                   boolean bool){
		fileName = FileUtils.processFileTail(fileName,Constants.XLS);
		if(bool){
			try {
				log.debug("导出excel到指定的路径！！！");
				//得到输出路径，用到时间戳
				String filePath = FileUtils.createTimeBag(Constants.outPath);
				//输出路径处理 文件名 根后缀
				filePath = filePath + fileName;
				FileOutputStream out = new FileOutputStream(filePath);
				webbook.write(out);
				out.flush();
				out.close();
				response.reset();
				response.setContentType("text/html;charset=GBK");
				response.getWriter().println("<script language=\"javascript\" type=\"\">");
				response.getWriter().println("alert(\"EXCEL 生成成功 ！！\");");
				response.getWriter().println("window.close();");
				response.getWriter().println("</script>");
			} catch (Exception e) {
				e.printStackTrace();
			}
		}else{
			try {
				log.debug("下载excel到本地！！！");
				//文件流输出
				response.reset();
				response.setContentType("application/vnd.ms-excel;charset=GBK");
	            response.setHeader("Content-Disposition", "attachment;filename=\"" +
	            		new String(fileName.getBytes("GBK"),"iso-8859-1")+"\"");
	            
				ServletOutputStream out = response.getOutputStream();
				webbook.write(out);
				if(out!=null){
				 out.flush();
				 out.close();
				}
				
			} catch (Exception e) {
				log.debug("输出excel出错："+e);
				e.printStackTrace();
			}
		}
	}
	
	//生成单元格
	private void createTableCell(HSSFRow row,Object [] names){
		int e=0;
		Object oo=null;
		for(int k=0;k<names.length;k++){
			//cell
			oo = names[k]; 
			HSSFCell cell2 = row.createCell((short) e);
			 
			if(oo instanceof Double){
				createRow(cell2,smallRight);
				cell2.setCellValue(((Double)oo).doubleValue());
			}else if(oo instanceof Integer){
				createRow(cell2,smallRight);
				cell2.setCellValue(((Integer)oo).intValue());
			
//			}else if(oo instanceof Date){
//				createRow(cell2,smallMiddle);
//				cell2.setCellValue((String)(FormatUtil.processDate((Date)oo)));
			}else{
				if(k==0){
					createRow(cell2,smallMiddle);
				}else{
					createRow(cell2,smallLeft);
				}
				if(oo==null) oo=" ";
				cell2.setCellValue(oo.toString());
			}
			e++;
			oo=null;
		}
	}
	
	//单表头
	private void createSingleCell(String[] [] names){
		
		int i=0;
		for(int k=0;k<names.length;k++){
			//cell
			cell = row.createCell((short) i);
			createRow(cell,smallMiddle);
			cell.setCellValue((String)names[k][0]);
			i++;
		}  
		
	}
	
	//二维表头
	private void createDoubleCell(String[] [] names){
		
		int vv=0;//第一行
		for(int k=0;k<names.length;k++){
			String[] name = (String[]) names[k];
			if(name.length==1){
				cell = row.createCell((short) vv);
				createRow(cell,smallMiddle);
				cell.setCellValue((String)name[0]);
				vv++;
			}else{
				Tosplit ts=new Tosplit();
				for(int u=0;u<ts.Splited(name[1]).length;u++){
					cell = row.createCell((short) vv);
					createRow(cell,smallMiddle);
					cell.setCellValue(name[0]);
					vv++;
				}
			}
		}
		row = sheet.createRow((short) 3);//第二行
		int z=0;
		for(int f=0;f<names.length;f++){
			String[] name = (String[]) names[f];
			if(name.length==1){
				cell = row.createCell((short) z);
				createRow(cell,smallMiddle);
				cell.setCellValue("");	
				z++;
			}else{
				Tosplit ts=new Tosplit();
				String[] gg =ts.Splited(name[1]);
				for(int y=0;y<gg.length;y++){
					cell = row.createCell((short) z);
					createRow(cell,smallMiddle);
					cell.setCellValue(gg[y]);
					z++;
				}
			}
		}
		
		//开始合并单元格
		vv=0;
		for(int k=0;k<names.length;k++){
			String[] name = (String[]) names[k];
			if(name.length==1){
				sheet.addMergedRegion(new Region(2, (short) vv, 3,(short)vv));
				vv++;
			}else{
				Tosplit ts=new Tosplit();
				int q = ts.Splited(name[1]).length;
				sheet.addMergedRegion(new Region(2, (short) vv, 2,(short)(vv+q-1)));
				for(int w=0;w<q;w++)
					vv++;
			}
		}

	}
	
	//3维表头
	private void createThirdCell(String[] [] names){
		int i=0;//第一行
		for(int k=0;k<names.length;k++){
			String[] name = (String[]) names[k];
			int count = getCellCount(name);
			for(int d = 0;d<count;d++){//创建单元格
				cell = row.createCell((short) (d+i));
				createRow(cell,smallMiddle);
				cell.setCellValue(name[0]);
			}
			sheet.addMergedRegion(new Region(2, (short) i, 2,(short)(i+count-1)));//横向合并
			i = i+count;
		}
		row = sheet.createRow((short) 3);//第4行
		i=0;
		for(int k=0;k<names.length;k++){
			String[] name = (String[]) names[k];
			if(name.length==1){
				cell = row.createCell((short) i);
				createRow(cell,smallMiddle);
				cell.setCellValue("");	
				i++;
			}else{
				Tosplit ts=new Tosplit();
				for(int f=1;f<name.length;f++){//从第二个开始读取
					
					String [] second = ts.TwoSplited(name[f]);
					if(second.length==1){
						cell = row.createCell((short) i);
						createRow(cell,smallMiddle);
						cell.setCellValue(second[0]);
						i++;
					}else{
						
						int flag = ts.Splited(second[1]).length;
						sheet.addMergedRegion(new Region(3, (short) i, 3,(short)(i+flag-1)));//横向合并
						for(int w=0;w<flag;w++){
							cell = row.createCell((short) i);
							createRow(cell,smallMiddle);
							cell.setCellValue(second[0]);
							i++;
						}
					}
				}
			}
		}
		
		row = sheet.createRow((short) 4);//第5行
		i=0;
		for(int k=0;k<names.length;k++){
			String[] name = (String[]) names[k];
			if(name.length==1){
				cell = row.createCell((short) i);
				createRow(cell,smallMiddle);
				cell.setCellValue("");	
				i++;
			}else{
				Tosplit ts=new Tosplit();
				for(int f=1;f<name.length;f++){//从第二个开始读取
					String [] second =ts.TwoSplited( name[f]);
					if(second.length==1){
						cell = row.createCell((short) i);
						createRow(cell,smallMiddle);
						cell.setCellValue("");
						i++;
					}else{
						
						int flag = ts.Splited(second[1]).length;
						for(int w=0;w<flag;w++){
							cell = row.createCell((short) i);
							createRow(cell,smallMiddle);
							cell.setCellValue(ts.Splited(second[1])[w]);
							i++;
						}
					}
				}
			}
		}
		
		i=0;//合并单元格
		for(int k=0;k<names.length;k++){
			String[] name = (String[]) names[k];
			if(name.length==1){
				sheet.addMergedRegion(new Region(2, (short) i, 4,(short)i));
				i++;
			}else{
				Tosplit ts=new Tosplit();
				for(int h=1;h<name.length;h++){
					String [] second = ts.TwoSplited(name[h]);
					if(second.length==1){
						sheet.addMergedRegion(new Region(3, (short) i, 4,(short)i));
						i++;
					}else{
						
						for(int y=0;y<ts.Splited(second[1]).length;y++)
							i++;
					}
				}
			}
		}
	}
	
	//4 维表头
	private void createFourthCell(String[][][] fourNames){
		
		int i=0;//第一行
		for(int k=0;k<fourNames.length;k++){
			String [][] names = fourNames[k];
			int result = getCellCountFourth(names);
			if(names.length==1)
				result++;
			for(int d = 0;d<result;d++){//创建单元格
				cell = row.createCell((short) (d+i));
				createRow(cell,smallMiddle);
				cell.setCellValue(names[0][0]);
			}
			if(result!=1)
				sheet.addMergedRegion(new Region(2, (short) i, 2,(short)(i+result-1)));//横向合并
			i = i+result;
		}
		
		row = sheet.createRow((short) 3);//第4行
		i=0;
		for(int k=0;k<fourNames.length;k++){
			String [][] names = fourNames[k];
			if(names.length==1){
				cell = row.createCell((short) i);
				createRow(cell,smallMiddle);
				cell.setCellValue("");	
				i++;
			}else{
				for(int f=1;f<names.length;f++){//从第二个开始读取
					String [] second = names[f];
					int count = getCellCount(second);
					for(int d = 0;d<count;d++){//创建单元格
						cell = row.createCell((short) (d+i));
						createRow(cell,smallMiddle);
						cell.setCellValue(second[0]);//print something in here
					}
					sheet.addMergedRegion(new Region(3, (short) i, 3,(short)(i+count-1)));//横向合并
					i = i+count;
				}
			}
		}
		
		row = sheet.createRow((short) 4);//第5行
		i=0;
		for(int k=0;k<fourNames.length;k++){
			String [][] names = fourNames[k];
			if(names.length==1){
				cell = row.createCell((short) i);
				createRow(cell,smallMiddle);
				cell.setCellValue("");	
				i++;
			}else{
				for(int f=1;f<names.length;f++){//从第二个开始读取
					String [] second = names[f];
					if(second.length==1){
						cell = row.createCell((short) i);
						createRow(cell,smallMiddle);
						cell.setCellValue(second[0]);	
						i++;
					}else{
						for(int yy=1;yy<second.length;yy++){
							Tosplit ts=new Tosplit();
							int flag = ts.Splited(second[yy]).length;
							sheet.addMergedRegion(new Region(4, (short) i, 4,(short)(i+flag-1)));//横向合并
							for(int w=0;w<flag;w++){
								cell = row.createCell((short) i);
								createRow(cell,smallMiddle);
								cell.setCellValue(ts.TwoSplited(second[yy])[0]);
								i++;
							}
						}
					}
				}
			}
		}
		
		row = sheet.createRow((short) 5);//第6行
		i=0;
		for(int k=0;k<fourNames.length;k++){
			String [][] names = fourNames[k];
			if(names.length==1){
				cell = row.createCell((short) i);
				createRow(cell,smallMiddle);
				cell.setCellValue("");	
				i++;
			}else{
				for(int f=1;f<names.length;f++){//从第二个开始读取
					String [] second = names[f];
					if(second.length==1){
						cell = row.createCell((short) i);
						createRow(cell,smallMiddle);
						cell.setCellValue("");	
						i++;
					}else{
						Tosplit ts=new Tosplit();
						for(int m=1;m<second.length;m++){//从第二个开始读取
							String [] third = ts.TwoSplited(second[m]);
							if(third.length==1){
								cell = row.createCell((short) i);
								createRow(cell,smallMiddle);
								cell.setCellValue("");
								i++;
							}else{
								
								int flag = ts.Splited(third[1]).length;
								for(int w=0;w<flag;w++){
									cell = row.createCell((short) i);
									createRow(cell,smallMiddle);
									cell.setCellValue(ts.Splited(third[1])[w]);
									i++;
								}
							}
						}
					}
				}
			}
		}
	
		
		//合并单元格
		i=0;//合并单元格
		for(int k=0;k<fourNames.length;k++){
			String[][] names =  fourNames[k];
			if(names.length==1){
				sheet.addMergedRegion(new Region(2, (short) i, 5,(short)i));
				i++;
			}else{
				for(int q=1;q<names.length;q++){
					String[] rr = names[q];
					if(rr.length==1){
						sheet.addMergedRegion(new Region(3, (short) i, 5,(short)i));
						i++;
					}else{
						Tosplit ts=new Tosplit();
						for(int h=1;h<rr.length;h++){
							String [] second = ts.TwoSplited(rr[h]);
							if(second.length==1){
								sheet.addMergedRegion(new Region(4, (short) i, 5,(short)i));
								i++;
							}else{
								for(int y=0;y<ts.Splited(second[1]).length;y++)
									i++;
							}
						}
					}
				}
			}
		}
	}
	
    //得到 4维表头 要合并的的单元格数目
	private int getCellCountFourth(String [][] arg){
		int count = 0;
		int result = 0;
		if(arg.length==1)
			count=1;
		else{
			for(int t=0;t<arg.length;t++){
				result = getCellCount(arg[t]);
				count = count + result;
			}
		}
		return count-1;
	}

	//得到 3维表头 要合并的的单元格数目
	private int getCellCount(String [] arg){
		int count = 0;
		if(arg.length==1){
			count=1;
		}else{
			Tosplit ts=new Tosplit();
			for(int j=1;j<arg.length;j++){//如果里面多于 一个元素，说明下面有分支
				String gg = arg[j];
				int p = ts.TwoSplited(gg).length;
				if(p==1){//就一行，下面没分支
					count = count + 1;
				}
				if(p>1){//里面有嵌套
					count = count + ts.Splited(ts.TwoSplited(gg)[1]).length;//得到下一级的个数
				}
			}
		}
		return count;
	}
	//单元格属性
	private void createRow(HSSFCell cell,HSSFCellStyle style){
		cell.setEncoding(HSSFCell.ENCODING_UTF_16);
		cell.setCellType(HSSFCell.CELL_TYPE_STRING);
		cell.setCellStyle(style);
	}
	
	//得到字体等属性
	private HSSFCellStyle getStyle(int fontSize,String fontWeight,short sh){
		HSSFFont font = workbook.createFont();
		HSSFCellStyle style = workbook.createCellStyle();
		//begin
		font.setFontName("宋体");
		//font height
		font.setFontHeightInPoints((short) fontSize);
		//bold weight
		if(fontWeight.equals("bold"))
			font.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD);
		else
			font.setBoldweight((short)0);
		
		style.setFont(font);
		style.setAlignment(sh);
		style.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER);

		return style;
	}

	//导出 WORD
	public void exportWORD() {
		
	}

	//导出 PDF
	public void exportPDF() {
		
	}

	//导出 html，2维数组
	public String exportHTML(String titleType, String[][] names, List list, String branchName, String createName, String fileName) {
		return null;
	}
	//导出 html,3 维数组
	public String exportHTML(String titleType, String[][][] names, List list, String branchName, String createName, String fileName) {
		return null;
	}

	public void exportPDF(HttpServletResponse response) {
		// TODO Auto-generated method stub
		
	}

	public void exportPDFTable(HttpServletResponse response) {
		// TODO Auto-generated method stub
		
	}
	
	
	// 类型 日期 和名称
	private String getTitle_InterBankCount(String msgtype,String prodate){
		StringBuffer sb=new StringBuffer();
		sb.append(" "+Constants.msgtype+"："+msgtype);
		sb.append("        "+Constants.prodate+": "+prodate);
	 
		return sb.toString();
	}
	//合并 表头
	private void mergeCell_InterBankCount(int cellNum,
						    String msgtype,
						    String prodate,
						    String fileName){
		
		sheet.addMergedRegion(new Region(0, (short) 0, 0,(short)(cellNum-1)));
		cell = row.createCell((short) 0);
		createRow(cell,bigBold);
		cell.setCellValue(fileName);
		row = sheet.createRow((short) 1);//第二行
		sheet.addMergedRegion(new Region(1, (short) 0, 1,(short)(cellNum-1)));
		cell = row.createCell((short) 0);
		createRow(cell,smallBold);
		cell.setCellValue(getTitle_InterBankCount(msgtype,prodate));
		row = sheet.createRow((short) 2);//第3行
	}
	//String titleType,String[][] names,List list,String fileName,HttpServletResponse response, String msgtype,String prodate,String tradingcount,String tradingamt,String tradingsxf
		
	public void exportExcel_InterBankCount(String titleType,            //表头类型
            String [][] names,           //表头值
            List list,	
            String fileName, 
            HttpServletResponse response,//response
            String msgtype,
	        String prodate,
	        String tradingcount,
	        String tradingamt,
	        String tradingsxf
            ){               //文件名
			
			try {
			j=1;
			row = sheet.createRow((short) (j-1));
			if(titleType.equals("1")){//单表头
			log.debug("单表头文件");
			mergeCell_InterBankCount(names.length,msgtype,prodate,fileName);
			createSingleCell(names);
			j=4;
			}else if(titleType.equals("2")){//2 维表头 
			log.debug("2维表头文件");
			mergeCell_InterBankCount(getCellSum2(names),msgtype,prodate,fileName);
			createDoubleCell(names);
			j=5;
			}else if(titleType.equals("3")){//3 维表头 
			log.debug("3维表头文件");
			mergeCell_InterBankCount(getCellSum3(names),msgtype,prodate,fileName);
			createThirdCell(names);
			j=6;
			}
			
			Iterator it = list.iterator();
			while(it.hasNext()){
			HSSFRow row2 = sheet.createRow((short) (j-1));
			List ll = (List) it.next();
			createTableCell(row2,ll.toArray());
			j++;
			}
			HSSFRow rowd = sheet.createRow((short) (j));
			HSSFCell cell0 = rowd.createCell((short)0);
			createRow(cell0,smallLeft);
			cell0.setCellValue("总计");
			HSSFCell cell1 = rowd.createCell((short)1);
			createRow(cell1,smallLeft);
			cell1.setCellValue("  ");
			HSSFCell cell2 = rowd.createCell((short)2);
			createRow(cell2,smallLeft);
			cell2.setCellValue(tradingcount);
			HSSFCell cell3 = rowd.createCell((short)3);
			createRow(cell3,smallLeft);
			cell3.setCellValue(tradingamt);
			HSSFCell cell4 = rowd.createCell((short)4);
			createRow(cell4,smallLeft);
			cell4.setCellValue(tradingsxf);
			//是否导出excel.或者直接在内存下载
			ifCreateExcel(workbook,response,fileName,false);
			} catch (Exception e) {
			log.error("导出excel出错："+e);
			e.printStackTrace();
			}
			}
				
}
