package com.xinleju.erp.flow.bean;

/**
 * 
 * 
 * <p>
 * </p>
 * <p>
 * </p>
 * 
 * @author 孙朝辉
 * @version $Id: Graph.java 583 2014-06-13 09:38:22Z sunchaohui $
 * @since
 * 
 */
public class Graph {

    /**
     * 数组最大支持
     */
    public static final int MAX_VERTS = 500;

    /**
     * 
     */
    private Vertex[] vertexList; // list of vertices

    /**
     * 
     */
    private int[][] adjMat; // adjacency matrix

    /**
     * 
     */
    private int ncVerts; // current number of vertices

    /**
     * 
     */
    private String[] sortedArray;

    // -------------------------------------------------------------
    public Graph() {
        vertexList = new Vertex[MAX_VERTS];
        // adjacency matrix
        adjMat = new int[MAX_VERTS][MAX_VERTS];
        ncVerts = 0;
        for (int j = 0; j < MAX_VERTS; j++) {
            // set adjacency
            for (int k = 0; k < MAX_VERTS; k++) {
                // matrix to 0
                adjMat[j][k] = 0;
            }
        }
        sortedArray = new String[MAX_VERTS]; // sorted vert labels
    } // end constructor

    // -------------------------------------------------------------

    /**
     * @param lab
     *            名称
     * 
     */
    public void addVertex(String lab) {
        vertexList[ncVerts++] = new Vertex(lab);
    }

    /**
     * 
     * @param start
     *            开始
     * @param end
     *            结束
     * 
     */
    public void addEdge(int start, int end) {
        adjMat[start][end] = 1;
    }

    /**
     * 
     * 
     * 
     * @author 孙朝辉
     * @param v
     *            索引
     * 
     */
    public void displayVertex(int v) {
        System.out.print(vertexList[v].getLabel());
    }

    /**
     * 
     * 
     * 
     * @author 孙朝辉
     * @return sortedArray
     */
    public String[] topo() {

        while (ncVerts > 0) {
            // get a vertex with no successors, or -1
            int currentVertex = noSuccessors();
            if (currentVertex == -1) {
                System.out.println("ERROR: Graph has cycles");

            }
            // insert vertex label in sorted array (start at end)
            sortedArray[ncVerts - 1] = vertexList[currentVertex].getLabel();

            deleteVertex(currentVertex); // delete vertex
        } // end while

        return sortedArray;

    } // end topo

    /**
     * 
     * 
     * 
     * @author 孙朝辉
     * 
     * @return int
     */
    public int noSuccessors() {
        boolean isEdge; // edge from row to column in adjMat

        for (int row = 0; row < ncVerts; row++) {
            isEdge = false; // check edges
            for (int col = 0; col < ncVerts; col++) {
                if (adjMat[row][col] > 0) { // another,
                    isEdge = true;
                    break; // this vertex
                } // has a successor
            } // try another
            if (!isEdge) {
                return row; // has no successors
            }
        }
        return -1; // no such vertex
    } // end noSuccessors()

    /**
     * 
     * 
     * 
     * @author 孙朝辉
     * @param delVert
     *            x
     */
    public void deleteVertex(int delVert) {
        if (delVert != ncVerts - 1) { // delete from vertexList
            for (int j = delVert; j < ncVerts - 1; j++) {
                vertexList[j] = vertexList[j + 1];
            }
            // delete row from adjMat
            for (int row = delVert; row < ncVerts - 1; row++) {
                moveRowUp(row, ncVerts);
            }
            // delete col from adjMat
            for (int col = delVert; col < ncVerts - 1; col++) {
                moveColLeft(col, ncVerts - 1);
            }
        }
        ncVerts--; // one less vertex
    } // end deleteVertex

    /**
     * 
     * 
     * 
     * @author 孙朝辉
     * @param row
     *            行号
     * @param length
     *            长度
     * 
     */
    private void moveRowUp(int row, int length) {
        for (int col = 0; col < length; col++) {
            adjMat[row][col] = adjMat[row + 1][col];
        }
    }

    /**
     * 
     * 
     * 
     * @author 孙朝辉
     * @param col
     *            x
     * @param length
     *            x
     */
    private void moveColLeft(int col, int length) {
        for (int row = 0; row < length; row++) {
            adjMat[row][col] = adjMat[row][col + 1];
        }
    }
    // -------------------------------------------------------------
} // end class Graph
