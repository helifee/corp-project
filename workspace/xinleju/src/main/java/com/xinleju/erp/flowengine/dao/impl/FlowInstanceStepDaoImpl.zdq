package com.xinleju.erp.flowengine.dao.impl;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import com.xinleju.erp.flow.dao.impl.BaseDAO;
import com.xinleju.erp.flowengine.dao.FlowInstanceStepDao;
import com.xinleju.erp.flowengine.dto.FlowInstanceStepDto;
import com.xinleju.erp.flowengine.dto.FlowInstanceStepTaskBackDto;

import com.xinleju.erp.flowengine.models.FlowInstanceStep;
import com.xinleju.erp.flowengine.utils.FlowInstanceStatus;
import com.xinleju.erp.flowengine.utils.StepTypeStatus;

@Repository
public class FlowInstanceStepDaoImpl extends BaseDAO implements FlowInstanceStepDao {

	@Autowired
	private JdbcTemplate jt;
	
	/* (non-Javadoc)
	 * @see com.xinleju.erp.flowengine.dao.FlowInstanceStepDao#getFlowInstanceStepDtoByFiId(java.lang.String)
	 */
	public List<FlowInstanceStepDto> getFlowInstanceStepDtoByFiId(String fiId){
		String sql = "SELECT\n" +
				"	fis.guid id,\n" +
				"	fis.is_start isStart,\n" +
				"	fis.display_name displayName\n" +
				"FROM\n" +
				"	flow_instance fi,\n" +
				"	flow_instance_step fis\n" +
				"WHERE\n" +
				"	fi.guid = fis.fi_id\n" +
				"AND fis.status = ?\n" +
				"AND fi.status = ?\n" +
				"AND fi.guid = ?\n" +
				"ORDER BY fis.sort,fis.num";
		
		return jt.query(sql, new RowMapper<FlowInstanceStepDto>(){
			@Override
			public FlowInstanceStepDto mapRow(ResultSet rs, int rowNum) throws SQLException {
				
				FlowInstanceStepDto flowInstanceStep = new FlowInstanceStepDto();
				
				flowInstanceStep.setGuid(rs.getString("id"));
				flowInstanceStep.setIsStart(rs.getInt("isStart"));
				flowInstanceStep.setDisplayName(rs.getString("displayName"));
				
				return flowInstanceStep;
			}
			
		},StepTypeStatus.STATUS_COMPLETE,FlowInstanceStatus.STATUS_RUNNING,fiId);
	}
	
	
	
	

	@Override
	public FlowInstanceStep getFlowInstanceStepByStepId(String stepId) {
		// TODO Auto-generated method stub
		return getDao().getById(FlowInstanceStep.class, stepId);
	}





	@Override
	public List<Integer> getSuperFlowInstanceStepsStatus(String StepId) {
		// TODO Auto-generated method stub
		String sql = "select p.status from flow_instance_step p ,flow_instance_step_relation  r where p.guid=r.step_id and r.next_step_id= ? ";
		return jt.queryForList(sql, new Object[]{StepId},Integer.class);
	}

	@Override
	public List<FlowInstanceStep> getSuperFlowInstanceStepsByStepId(
			String StepId) {
		// TODO Auto-generated method stub
		List<FlowInstanceStep>  steps=getDao().findByHQL(FlowInstanceStep.class, " select p from FlowInstanceStep p,FlowInstanceStepRelation  r where p.id=r.stepId and r.nextStepId=? ", new Object[]{StepId});
		return steps;
	}
	

	@Override
	public List<FlowInstanceStepTaskBackDto> getFlowInstanceStepTaskBackDtoByFiId(
			String fiId) {
		// TODO Auto-generated method stub
		String sql = "SELECT\n" +
				"	fis.guid id,\n" +
				"   fis.fi_id fi_id,\n" +
				"	fis.is_start isStart,\n" +
				"  kk.guid task_id,\n" +
				"  kk.work_id,\n" +
				"  kk.complete_user_name,\n" +
				"  kk.complete_user_id,\n"+
				"  fis.display_name displayName\n" +
				"FROM\n" +
				"	flow_instance fi,\n" +
				"	flow_instance_step fis, \n" +
				"	flow_instance_step_work_task kk\n" +
				"WHERE\n" +
				"	fi.guid = fis.fi_id \n" +
			//	"AND kk.complete_user_id is not null AND kk.complete_user_id!='' \n"+
				"AND kk.step_id=fis.guid \n"+
				"AND kk.assign_task_id is null \n"+
				"AND fis.status = ?\n" +
				"AND fi.status = ?\n" +
				"AND fi.guid = ?\n" +
				"ORDER BY fis.sort,fis.num";
		
		List<FlowInstanceStepTaskBackDto> flowInstanceStepTaskBackDtos= jt.query(sql, new RowMapper<FlowInstanceStepTaskBackDto>(){
			private int i=1;
			private String stepId="";
			@Override
			public FlowInstanceStepTaskBackDto mapRow(ResultSet rs, int rowNum) throws SQLException {
				
				FlowInstanceStepTaskBackDto flowInstanceStepTaskBackDto = new FlowInstanceStepTaskBackDto();
				flowInstanceStepTaskBackDto.setNum(i);
				if(!stepId.equals(rs.getString("id"))){
					i=i+1;
				}
				flowInstanceStepTaskBackDto.setStepId(rs.getString("id"));
				flowInstanceStepTaskBackDto.setFiId(rs.getString("fi_id"));
				flowInstanceStepTaskBackDto.setTaskId(rs.getString("task_id"));
				flowInstanceStepTaskBackDto.setWorkId(rs.getString("work_id"));
				flowInstanceStepTaskBackDto.setComplete_user_id(rs.getString("complete_user_id"));
				flowInstanceStepTaskBackDto.setComplete_user_name(rs.getString("complete_user_name"));
				flowInstanceStepTaskBackDto.setIsStart(rs.getInt("isStart"));
				flowInstanceStepTaskBackDto.setDisplayName(rs.getString("displayName"));
				
				return flowInstanceStepTaskBackDto;
			}
			
		},StepTypeStatus.STATUS_COMPLETE,FlowInstanceStatus.STATUS_RUNNING,fiId);
		//把自动活动的剔除掉
		List<FlowInstanceStepTaskBackDto> newflowInstanceStepTaskBackDtos=new ArrayList<FlowInstanceStepTaskBackDto>();
		if(flowInstanceStepTaskBackDtos!=null && flowInstanceStepTaskBackDtos.size()>0){
			for(FlowInstanceStepTaskBackDto flowInstanceStepTaskBackDto:flowInstanceStepTaskBackDtos){
				if(StringUtils.isNotEmpty(flowInstanceStepTaskBackDto.getComplete_user_name())){
					newflowInstanceStepTaskBackDtos.add(flowInstanceStepTaskBackDto);
				}
				
			}
		}
		return newflowInstanceStepTaskBackDtos;
	}




	@Override
	public Integer getProofreadStepUploadFileContByStepId(String fiId,Integer status,String proofreadCode) {
	 Integer i=0;
	 try{
		i= jt.queryForObject("SELECT\n" +
				"	count(1)\n" +
				"FROM\n" +
				"	flow_instance_step fis\n" +
				"INNER JOIN tf_op_group opg ON fis.approval_type = opg.id\n" +
				"INNER JOIN flow_instance_step_work_task fiswt ON fis.guid = fiswt.step_id\n" +
				"INNER JOIN sm_upload u ON fiswt.owner_id = u.owner_id\n" + 
				"WHERE\n" +
				"	fis.status = ?\n" +
				"AND opg.code = ?\n" +
				"AND fis.fi_id = ?",Integer.class,status,proofreadCode,fiId);
		}catch(Exception e){
			e.printStackTrace();
		}
	   return i;
	}


}
