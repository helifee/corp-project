package com.xinleju.erp.flow.utils;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.lang.reflect.InvocationTargetException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.beanutils.BeanUtils;
import org.apache.commons.lang3.StringUtils;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;

import com.mxgraph.model.mxCell;
import com.mxgraph.model.mxGraphModel;
import com.mxgraph.model.mxICell;
import com.mxgraph.util.mxUtils;
import com.xinleju.erp.base.app.config.Constant;
import com.xinleju.erp.base.utils.CollectionUtils;
import com.xinleju.erp.base.utils.DateUtils;
import com.xinleju.erp.base.utils.FileUtils;
import com.xinleju.erp.base.utils.ReflectionUtils;
import com.xinleju.erp.base.utils.StringHelper;
import com.xinleju.erp.flow.bean.Graph;
import com.xinleju.erp.flow.bean.IdName;
import com.xinleju.erp.flow.models.Ac;
import com.xinleju.erp.flow.models.AcMonitorSetting;
import com.xinleju.erp.flow.models.Tr;
import com.xinleju.erp.flow.service.impl.AndFinishTypeService;
import com.xinleju.erp.flow.service.impl.XorFinishTypeService;

/**
 * 
 * 
 * <p>
 * </p>
 * <p>
 * </p>
 * 
 * @author 孙朝辉
 * @version $Id: DesignerUtils.java 2309 2015-01-09 03:23:33Z zhongjun $
 * @since
 * 
 */
public class DesignerUtils {

    /**
     * 
     * <p>
     * </p>
     * <p>
     * </p>
     * 
     * @author 孙朝辉
     * @param model
     *            流程设计模型
     * @param cell
     *            流程设计节点
     * @param tr
     *            流转
     * @param flowCode
     *            流程编码
     * @param flowVersion
     *            流程按本
     * @return 流转(Tr)
     */
    public static Tr cellToTr(mxGraphModel model, mxCell cell, Tr tr, String flowCode, String flowVersion) {
        tr = (tr == null) ? new Tr() : tr;
        String cond = cell.getAttribute("cond", "");
        String source = cell.getSource().getId();
        String target = cell.getTarget().getId();
        String trId = cell.getId();
        String trName = cell.getAttribute("trName", "");
        String trPriority = cell.getAttribute("trPriority", "");
        String isDefault = cell.getAttribute("isDefault", "");
        // rebuild Tr cond

        tr.setCond(cond);
        tr.setFlowCode(flowCode);
        tr.setFlowVersion(flowVersion);
        tr.setSource(source);
        tr.setTarget(target);
        tr.setTrId(trId);
        tr.setTrName(trName);
        tr.setIsDefault(StringHelper.parseBoolean(isDefault) ? 1 : 0);
        tr.setTrPriority(StringUtils.isEmpty(trPriority) ? null : Integer.parseInt(trPriority));
        return tr;
    }

    /**
     * 
     * <p>
     * </p>
     * <p>
     * </p>
     * 
     * @author 孙朝辉
     * @param model
     *            流程设计模型
     * @param cell
     *            流程设计节点
     * @param ac
     *            环节
     * @param flowCode
     *            流程编码
     * @param flowVersion
     *            流程版本
     * @return 环节
     */
    public static Ac cellToAc(mxGraphModel model, mxCell cell, Ac ac, String flowCode, String flowVersion) {

        ac = (ac == null) ? new Ac() : ac;

        ac.setSort(0);
        ac.setNodeNote("");
        ac.setTp(0);
        ac.setOutCode("");

        ac.setFlowCode(flowCode);
        ac.setFlowVersion(flowVersion);
        Map<String, Object> valueMap = new HashMap<String, Object>();

        org.w3c.dom.Node node1 = (org.w3c.dom.Node) cell.getValue();

        NamedNodeMap map = node1.getAttributes();
        String fieldName = "";
        for (int i = 0; i < map.getLength(); i++) {
            Node item = map.item(i);
            fieldName = item.getNodeName();

            
            if (ReflectionUtils.hasDeclaredField(Ac.class, fieldName)) {
                Class<?> typeClass = ReflectionUtils.getDeclaredField(Ac.class, item.getNodeName()).getType();
                Object value = item.getNodeValue();
                if (value != null && StringUtils.isNotEmpty(String.valueOf(value))) {

                    String strVal = String.valueOf(value);
                    if (typeClass == String.class) {
                        value = strVal;
                        valueMap.put(item.getNodeName(), strVal);
                    } else if (typeClass == Integer.class || typeClass == int.class) {
                        try {
                            value = Integer.parseInt(strVal);
                            valueMap.put(item.getNodeName(), value);
                        } catch (Exception e) {
                            System.out.println(fieldName);
                            e.printStackTrace();
                        }
                    } else if (typeClass == BigDecimal.class) {
                        value = new BigDecimal(strVal);
                        valueMap.put(item.getNodeName(), value);
                    } else if (typeClass == Double.class) {
                        value = new Double(strVal);
                        valueMap.put(item.getNodeName(), value);
                    } else if (typeClass == Float.class) {
                        value = new Float(strVal);
                        valueMap.put(item.getNodeName(), value);
                    }
                }
            }
        }

        try {
            BeanUtils.copyProperties(ac, valueMap);
            ac.setNodeName(cell.getAttribute("label"));
            ac.setNodeId(cell.getId());
        } catch (IllegalAccessException e) {
            System.out.println(cell.getAttribute("label"));
            System.out.println(fieldName);

            e.printStackTrace();
        } catch (InvocationTargetException e) {
            System.out.println(cell.getAttribute("label"));
            System.out.println(fieldName);
            e.printStackTrace();
        }

        Object[] nextInfo = getNextCellsAsString(model, cell);
        Object[] fromInfo = getFromCellsAsString(model, cell);

        String next1 = (String) nextInfo[0];
        String nexta = (String) nextInfo[1];
        String nexttr1 = (String) nextInfo[2];
        String nexttra = (String) nextInfo[3];
        Integer nexttr1size = (Integer) nextInfo[4];

        String from1 = (String) fromInfo[0];
        String froma = (String) fromInfo[1];
        String fromtr1 = (String) fromInfo[2];
        String fromtra = (String) fromInfo[3];
        Integer fromtr1size = (Integer) fromInfo[4];

        ac.setNext_1(next1);
        ac.setNext_a(nexta);
        ac.setNext_tr_1(nexttr1);
        ac.setNext_tr_a(nexttra);
        ac.setNext_tr_1_size(nexttr1size);
        ac.setIsEnd(nexttr1size == 0 ? 1 : 0);

        ac.setFrom_1(from1);
        ac.setFrom_a(froma);
        ac.setFrom_tr_1(fromtr1);
        ac.setFrom_tr_a(fromtra);
        ac.setFrom_tr_1_size(fromtr1size);
        ac.setIsStart(fromtr1size == 0 ? 1 : 0);

        ac.setNodeId(cell.getId());

        // 默认值
        if (ac.getParticipantsSelectStrategy() == null) {
            // 参考Teleflow.js
            ac.setParticipantsSelectStrategy(FlowConstant.PARTICIPANT_SELECT_DEFAULT);
        }
        
        // 竞争
        if((ac.getNodeType() == null || ac.getNodeType().intValue() == 0) && !AndFinishTypeService.class.getName().equals(ac.getFinishCtrl()) 
                || XorFinishTypeService.class.getName().equals(ac.getFinishCtrl())){
            ac.setAssignType(0);
            ac.setFinishCtrl(XorFinishTypeService.class.getName());
        }
        // 串行
        else if(ac.getNodeType() != null && ac.getNodeType().intValue() == 1){
            ac.setAssignType(1);
            ac.setFinishCtrl(AndFinishTypeService.class.getName());
        }
        // 会审
        else if(ac.getNodeType() != null && ac.getNodeType().intValue() == 2 || AndFinishTypeService.class.getName().equals(ac.getFinishCtrl())){
            ac.setAssignType(0);
            ac.setFinishCtrl(AndFinishTypeService.class.getName());
        }
        
        if(StringUtils.isEmpty(ac.getFinishCtrl())){
            
        }
        
        return ac;
    }

    /**
     * 
     * @param model 流程模型
     * @param cell  流程环节
     * @param acms  环节监控设置
     * @return 环节监控设置
     */
    public static AcMonitorSetting cellToAcMonitorSetting(mxGraphModel model, mxCell cell, Long flId) {

    	AcMonitorSetting acms = new AcMonitorSetting();

    	acms.setApproverOvertime(StringUtils.isEmpty(cell.getAttribute("approverOvertime"))  ? null : Long.valueOf(cell.getAttribute("approverOvertime")));
    	acms.setApproverRate(StringUtils.isEmpty(cell.getAttribute("approverRate")) ? null : Integer.parseInt(cell.getAttribute("approverRate")));
    	acms.setLeaderId(StringUtils.isEmpty(cell.getAttribute("leaderId")) ? null : cell.getAttribute("leaderId"));
    	acms.setLeaderName(StringUtils.isEmpty(cell.getAttribute("leaderName")) ? null : cell.getAttribute("leaderName"));
    	acms.setLeaderOvertime(StringUtils.isEmpty(cell.getAttribute("approverOvertime"))  ? null : Long.valueOf(cell.getAttribute("approverOvertime")));
    	acms.setLeaderRate(StringUtils.isEmpty(cell.getAttribute("leaderRate")) ? null : Integer.parseInt(cell.getAttribute("leaderRate")));
    	acms.setFlId(flId);
    	acms.setNodeId(cell.getId());
    	acms.setStatus(StringUtils.isEmpty(cell.getAttribute("status")) ? null : Integer.parseInt(cell.getAttribute("status")));
        
        return acms;
    }
    
    /**
     * 
     * <p>
     * 创建新流程时,默认的XML配置
     * </p>
     * <p>
     * </p>
     * 
     * @author 孙朝辉
     * @param flowCode
     *            流程编码
     * @param flowVersion
     *            流程版本
     * @param ctId
     *            流程目录
     * @return XML
     */
    public static String getNewXML(String flowCode, String flowVersion, String ctId,String flowCtName, String serviceObjectDefineId, IdName idName) {
        String xml = "<mxGraphModel>";
        xml += "<root>";
        xml += "<Workflow flowName=\"新流程\" flowVersion=\"" + flowVersion + "\" "
        + " flowCode=\"" + flowCode + "\""
        + " ctId=\"" + (StringUtils.isNotBlank(ctId) ? Long.valueOf(ctId) : "") + "\""
        + " flowCtName=\"" + (StringUtils.isNotBlank(flowCtName) ? flowCtName : "") + "\""
        + " serviceObjectDefineId=\"" + (StringUtils.isNotBlank(serviceObjectDefineId) ? Long.valueOf(serviceObjectDefineId) : "") + "\""
        + " createTime=\"" + DateUtils.formatDate(new Date(), DateUtils.DATE_FORMAT_YYYY_MM_DD_HH_MM_SS) + "\""
        + " updateTime=\"\"";
        if (null != idName){
            xml += " createUserId=\""  + (null != idName.getId() ? idName.getId() : "") + "\"";
            xml += " createUserLoginName=\""  + (StringUtils.isNotBlank(idName.getCode()) ? idName.getCode() : "") + "\"";
            xml += " createUserName=\""  + (StringUtils.isNotBlank(idName.getName()) ? idName.getName() : "") + "\"";
        }
        xml += " titleType=\"@title@-@user@\"";
        xml += " codePrefix=\"@公司编号@-@年度@-@月份@\"";
        xml += " editUserId=\"\"";
        xml += " editUserName=\"\"";
        xml += " canChangeTitle=\"1\"";
        xml += " editUserLoginName=\"\"";
        xml += " id=\"0\" isTimeLimit=\"0\"/>";
        xml += "<Layer label=\"\">";
        xml += "<mxCell parent=\"0\"/>";
        xml += "</Layer>";
        xml += "</root>";
        xml += "</mxGraphModel>";

        return xml;
    }

    
    public static String getTemplateXML(String flowCode, String flowVersion) {
       try {
           
         
        String xml = FileUtils.streamToString(new FileInputStream(new File(Constant.CONFIG_PATH + File.separator + "designer/examples/editors/config/sample.xml")), "UTF-8");
        xml = xml.replace("_FLOWVERSION_", flowVersion);
        xml = xml.replace("_FLOWCODE_", flowCode);
       return xml;
       } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (Exception e) {
        e.printStackTrace();
    }
        return null;
    }
    /**
     * 
     * <p>
     * 返回Cell的后置元信息
     * </p>
     * <p>
     * 包括:后置的节点ID信息
     * </p>
     * 
     * @author 孙朝辉
     * @param model
     *            流程模型对象
     * @param c
     *            当前节点
     * @return 元信息，依次：[直接后置节点NodeId,所有后置节点NodeId,直接后置流转TrId,所有后置TrId,直接后置Tr数量]
     */
    public static Object[] getNextCellsAsString(mxGraphModel model, mxICell c) {

        // 参与人.环节参与人
        List<mxICell> finderListA = new ArrayList<mxICell>();
        List<mxICell> finderList1 = new ArrayList<mxICell>();
        List<mxICell> trFinderList1 = new ArrayList<mxICell>();
        List<mxICell> trFinderListA = new ArrayList<mxICell>();

        List<mxICell> wkList = new ArrayList<mxICell>();
        wkList.add(c);

        Map<String, Object> map = model.getCells();
        int depth = 1;

        while (wkList.size() > 0) {
            List<mxICell> store = new ArrayList<mxICell>();

            for (int k = 0; k < wkList.size(); k++) {
                mxICell fromCell = wkList.get(k);

                for (Object vv : map.values()) {
                    mxICell kkCell = (mxICell) vv;
                    if (kkCell.isEdge()) {

                        mxCell edge = (mxCell) kkCell;
                        mxICell source = edge.getSource();

                        if (source.getId().equals(fromCell.getId())) {
                            if (!finderListA.contains(edge.getTarget())) {
                                finderListA.add(edge.getTarget());
                            }
                            if (!trFinderListA.contains(edge)) {
                                trFinderListA.add(edge);
                            }

                            store.add(edge.getTarget());

                            if (depth == 1) {
                                finderList1.add(edge.getTarget());
                                trFinderList1.add(edge);
                            }
                        }
                    }
                }
            }
            if (store.size() == 0) {
                break;
            } else {
                wkList = store;
            }

            depth++;
        }

        String nextIds1 = CollectionUtils.collectAsString(finderList1, "id", "-");
        String nextIds = CollectionUtils.collectAsString(finderListA, "id", "-");

        String next1trids = CollectionUtils.collectAsString(trFinderList1, "id", "-");
        String nextATrIds = CollectionUtils.collectAsString(trFinderListA, "id", "-");
        return new Object[] { nextIds1, nextIds, next1trids, nextATrIds, trFinderList1.size() };
    }

    /**
     * 
     * <p>
     * 返回Cell的前置元信息
     * </p>
     * <p>
     * 包括:前置的节点ID信息
     * </p>
     * 
     * @author 孙朝辉
     * @param model
     *            流程模型对象
     * @param c
     *            当前节点
     * @return 元信息，依次：[直接后置节点NodeId,所有后置节点NodeId,直接后置流转TrId,所有后置TrId,直接后置Tr数量]
     */
    public static Object[] getFromCellsAsString(mxGraphModel model, mxICell c) {

        // 参与人.环节参与人
        List<mxICell> finderListA = new ArrayList<mxICell>();
        List<mxICell> finderList1 = new ArrayList<mxICell>();
        List<mxICell> trFinderList1 = new ArrayList<mxICell>();
        List<mxICell> trFinderListA = new ArrayList<mxICell>();
        List<mxICell> wkList = new ArrayList<mxICell>();
        wkList.add(c);

        Map<String, Object> map = model.getCells();
        int depth = 1;
        while (wkList.size() > 0) {
            List<mxICell> store = new ArrayList<mxICell>();

            for (int k = 0; k < wkList.size(); k++) {
                mxICell toCell = wkList.get(k);

                for (Object vv : map.values()) {
                    mxICell kkCell = (mxICell) vv;
                    if (kkCell.isEdge()) {

                        mxCell edge = (mxCell) kkCell;
                        mxICell target = edge.getTarget();

                        if (target.getId().equals(toCell.getId())) {
                            if (!finderListA.contains(edge.getSource())) {
                                finderListA.add(edge.getSource());
                            }
                            if (!trFinderListA.contains(edge)) {
                                trFinderListA.add(edge);
                            }
                            store.add(edge.getSource());

                            if (depth == 1) {
                                finderList1.add(edge.getSource());
                                trFinderList1.add(edge);
                            }
                        }
                    }
                }
            }
            if (store.size() == 0) {
                break;
            } else {
                wkList = store;
            }

            depth++;
        }

        String fromIds1 = CollectionUtils.collectAsString(finderList1, "id", "-");
        String fromIds = CollectionUtils.collectAsString(finderListA, "id", "-");

        String nextTrIds = CollectionUtils.collectAsString(trFinderList1, "id", "-");
        String nextATrIds = CollectionUtils.collectAsString(trFinderListA, "id", "-");
        return new Object[] { fromIds1, fromIds, nextTrIds, nextATrIds, trFinderList1.size() };
    }

    /**
     * 
     * <p>
     * 拓扑排序
     * </p>
     * <p>
     * </p>
     * 
     * @author 孙朝辉
     * @param acList
     *            所有节点
     * @param trList
     *            所有流转
     */
    public static void topo(List<Ac> acList, List<Tr> trList) {

        Graph g = new Graph();
        int index = 0;

        Map<String, Integer> matrixMap = new HashMap<String, Integer>();

        for (Ac ac : acList) {
            g.addVertex(ac.getNodeId());
            matrixMap.put(ac.getNodeId(), index++);
        }

        for (Tr tr : trList) {
            g.addEdge(matrixMap.get(tr.getSource()), matrixMap.get(tr.getTarget()));
        }

        String[] result = g.topo();

        Map<String, Integer> topoMap = new HashMap<String, Integer>();

        int sort = 1;
        for (String nodeId : result) {
            if (nodeId != null) {
                topoMap.put(nodeId, sort++);
            }
        }

        for (Ac ac : acList) {
            ac.setTp(topoMap.get(ac.getNodeId()));
        }
    }

    /**
     * 
     * <p>
     * 判断是否Task节点(而不是连线)
     * </p>
     * <p>
     * </p>
     * 
     * @author 孙朝辉
     * @param model
     *            模型
     * @param cell
     *            模型元素
     * @return 是否Task
     */
    public static boolean isTask(mxGraphModel model, mxCell cell) {
        return mxUtils.isNode(model.getValue(cell), "task") || mxUtils.isNode(model.getValue(cell), "shape");
    }

    /**
     * 
     * <p>
     * 对Ac进行手工排序
     * </p>
     * <p>
     * </p>
     * 
     * @author 孙朝辉
     * @param acList
     *            所有环节
     * @param xmlConfig
     *            outCode.xml 数据服务
     */
//    public static void sort(List<Ac> acList, XmlConfig xmlConfig) {
//
//        for (Ac ac : acList) {
//            String outCode = ac.getOutCode();
//            if (StringUtils.isNotEmpty(outCode)) {
//                OutCode oc = xmlConfig.getOutCode(outCode);
//
//                if (StringUtils.isNotEmpty(oc.getSort()) && StringUtils.isNumeric(oc.getSort())) {
//                    ac.setSort(Integer.parseInt(oc.getSort()));
//                }
//            }
//        }
//    }
}
