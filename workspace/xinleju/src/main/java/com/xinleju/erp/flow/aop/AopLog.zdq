package com.xinleju.erp.flow.aop;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Method;

import org.apache.log4j.Logger;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.Signature;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;

import com.xinleju.erp.flow.annotation.Description;

/**
 * 统一日志记录类
 * 
 * @author hongbin
 * @version 2014年5月12日
 *  AopLog
 * @since
 */
@Component("aopLog")
public class AopLog {
    /**
     * 获得日志类
     */
    private static final Logger LOG = Logger.getLogger(AopLog.class);

    /**
     * 定义切入点
     * 
     * 
     */
    public void pointcut() {
    }

    /**
     * 方法执行前执行
     * 
     * 
     */
    public void before() {
        // System.out.println("在方法执行前调用！");
    }

    /**
     * 方法执行后执行
     * 
     * 
     */
    public void after() {
        // System.out.println("方法执行后调用！");
    }

    /**
     * Description: 环绕执行，方法执行前后<br>
     * 
     * @param point
     *            切入点
     * @return Object
     * @throws Throwable
     *             异常
     * 
     */
    public Object around(ProceedingJoinPoint point) throws Throwable {
        // 获得方法注释
        MethodSignature methodSignature = (MethodSignature) point.getSignature();
        Method method = methodSignature.getMethod();
        Description methodDesc = method.getAnnotation(Description.class);
        if (methodDesc == null) {
            return point.proceed();
        }

        String clazzString = point.getTarget().getClass().getName();
        String methodName = point.getSignature().getName();
        String fullPath = clazzString + "." + methodName;
        String moduleName = getModuleName(point.getTarget().getClass(), point.getSignature());
        int flag = clazzString.indexOf("$");
        if (flag < 0) {
            LOG.debug("开始业务处理[" + moduleName + "];全路径[" + fullPath + "]");
        }
        long time = System.currentTimeMillis();
        Object retVal = point.proceed();
        time = System.currentTimeMillis() - time;
        if (flag < 0) {
            LOG.debug("结束业务处理[" + moduleName + "];耗时:" + time + "毫秒;全路径[" + fullPath + "]");
        }
        return retVal;
    }

    /**
     * 1、 如果使用该种写法则无法给doThrowing添加Throwable 2、 参数，如没有该参数我们无法获悉程序运行的错误:error at 0 formal unbound in pointcutd 3、故可修改成为如下:
     * 
     * @AfterThrowing(pointcut="pointcut()")
     * @param jp
     *            切入点
     * @param ex
     *            异常
     * 
     */
    public void doThrowing(JoinPoint jp, Throwable ex) {
        String clazzString = jp.getTarget().getClass().getName();
        String methodName = jp.getSignature().getName();
        String fullPath = clazzString + "." + methodName;
        String moduleName = getModuleName(jp.getTarget().getClass(), jp.getSignature());
        int flag = clazzString.indexOf("$");
        if (flag < 0) {
            LOG.error("业务处理时发生了异常:[" + moduleName + ":" + fullPath + "]");
            StringWriter sw = new StringWriter();
            ex.printStackTrace(new PrintWriter(sw));
            LOG.error(sw.toString());
        }
    }

    /**
     * 获得模块名称
     * 
     * @param claszz
     *            模块所在类
     * @param signature
     *            Signature
     * @return 返回模块名称路径
     * 
     */
    private String getModuleName(Class<? extends Object> claszz, Signature signature) {
        // 获得类注解
        Description classDesc = claszz.getAnnotation(Description.class);
        // 获得方法注释
        MethodSignature methodSignature = (MethodSignature) signature;
        Method method = methodSignature.getMethod();
        Description methodDesc = method.getAnnotation(Description.class);
        StringBuffer sb = new StringBuffer();
        if (classDesc != null) {
            sb.append(classDesc.name()).append("-->");
        }
        if (methodDesc != null) {
            sb.append(methodDesc.name());
        }
        return sb.toString();
    }
}
