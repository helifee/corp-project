package com.xinleju.erp.flow.utils;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang3.StringUtils;

import com.xinleju.erp.base.utils.CollectionUtils;
import com.xinleju.erp.base.utils.DateUtils;
import com.xinleju.erp.base.utils.StringHelper;
import com.xinleju.erp.flow.flowutils.bean.FlowResult;
import com.xinleju.erp.flow.flowutils.bean.Gvs;
import com.xinleju.erp.flow.flowutils.utils.WsConstant;
import com.xinleju.erp.flow.frameapi.domain.User;
import com.xinleju.erp.flow.models.Ac;
import com.xinleju.erp.flow.models.Ai;
import com.xinleju.erp.flow.models.Fi;
import com.xinleju.erp.flow.models.Fl;
import com.xinleju.erp.flow.models.Tr;
import com.xinleju.erp.flow.models.Wi;
import com.xinleju.erp.flow.models.Wp;
import com.xinleju.erp.flow.service.AiService.FromOrNext;
import com.xinleju.erp.flow.service.api.utils.ApiMsgUtils;
import com.xinleju.erp.flow.service.impl.AndFinishTypeService;
import com.xinleju.erp.flow.service.impl.XorFinishTypeService;

/**
 * 
 * 
 * <p>
 * </p>
 * <p>
 * </p>
 * 
 * @author 孙朝辉
 * @version $Id: FlowUtils.java 2160 2014-12-22 01:43:02Z sunchaohui $
 * @since
 * 
 */
public class FlowUtils {
    
    
    public static Map<String, Object> joinMap(Map<String, Object> tvs, Map<String, Object> _tvs) {
        if(tvs == null){
            tvs = new HashMap<String, Object>();
        }
        
        if(_tvs != null){
            for(Map.Entry<String,Object> e : _tvs.entrySet()){
                tvs.put(e.getKey(), e.getValue());
            }
        }
        return tvs;
    }

    
    public static boolean foundSignal(Gvs vs,String signalK,Object signalV){
        return vs.get(signalK) != null && vs.get(signalK).equals(signalV);
    }
    public static boolean foundSignal(Map<String,Object> vs,String signalK,Object signalV){
        return vs.get(signalK) != null && vs.get(signalK).equals(signalV);
    }
    /**
     * 
     * <p>
     * 获取工作参与人对象
     * </p>
     * <p>
     * </p>
     * 
     * @author 孙朝辉
     * @param wi
     *            工作
     * @return 用户对象
     */
    public static User getParticipant(Wi wi) {
        User user = new User();
        user.setLoginName(wi.getParticipantLoginName());
        user.setUserName(wi.getParticipantUserName());
        user.setUserId(wi.getParticipant());
        return user;
    }

    /**
     * 
     * <p>
     * 是否自动跳过工作组
     * </p>
     * <p>
     * </p>
     * 
     * @author 孙朝辉
     * @param wp
     *            工作组
     * @return 是/否
     */
    public static boolean isAutoPassWhenNoParticipants(Wp wp) {
        return wp != null && wp.getIsAutoAsNoParticipants() != null && wp.getIsAutoAsNoParticipants().intValue() == 1;
    }

    /**
     * 
     * <p>
     * 是否自动节点
     * </p>
     * <p>
     * </p>
     * 
     * @author 孙朝辉
     * @param ac
     *            节点
     * @return 是/否
     */
    public static boolean isAuto(Ac ac) {
        return ac.getIsAuto() != null && ac.getIsAuto() == 1;
    }

    /**
     * 
     * <p>
     * 判断流程是否被挂起
     * </p>
     * <p>
     * </p>
     * 
     * @author 孙朝辉
     * @param fi
     *            流程实例
     * @return 是/否
     */
    public static boolean isFiSuspend(Fi fi) {
        return fi.getIsSuspend() != null && fi.getIsSuspend() == 1;
    }

    /**
     * 
     * <p>
     * 判断活动实例是否被挂起
     * </p>
     * <p>
     * </p>
     * 
     * @author 孙朝辉
     * @param ai
     *            活动实例
     * @return 是/否
     */
    public static boolean isAiSuspend(Ai ai) {
        return ai.getIsSuspend() != null && ai.getIsSuspend() == 1;
    }

    /**
     * 
     * <p>
     * 判断工作是否影响流转
     * </p>
     * <p>
     * </p>
     * 
     * @author 孙朝辉
     * @param wi
     *            工作
     * @return 是/否
     */
    public static boolean isEffectFlow(Wi wi) {
        return wi.getIsEffectFlow() != null && wi.getIsEffectFlow().intValue() == 1;
    }

    /**
     * 
     * <p>
     * 从trId集合获取所有的Tr
     * </p>
     * <p>
     * trMap中存储所有的Tr
     * </p>
     * 
     * @author 孙朝辉
     * @param trIds
     *            目标TrId
     * @param trMap
     *            全量Tr集合
     * @return Tr集合
     */
    public static List<Tr> filterByTrIds(List<String> trIds, Map<String, Tr> trMap) {
        List<Tr> returnList = new ArrayList<Tr>();
        for (String k : trIds) {
            returnList.add(trMap.get(k));
        }
        return returnList;
    }

    /**
     * 
     * <p>
     * 从acIds集合获取所有的Ac
     * </p>
     * <p>
     * acMap中存储所有的Ac
     * </p>
     * 
     * @author 孙朝辉
     * @param acIds
     *            目标acId
     * @param acMap
     *            全量Ac集合
     * @return Ac集合
     */
    public static List<Ac> filterByAcIds(List<String> acIds, Map<String, Ac> acMap) {
        List<Ac> returnList = new ArrayList<Ac>();
        for (String k : acIds) {
            returnList.add(acMap.get(k));
        }
        return returnList;
    }

    /**
     * 
     * <p>
     * 从集合中发现流程首节点
     * </p>
     * <p>
     * </p>
     * 
     * @author 孙朝辉
     * @param acList
     *            环节集合
     * @return 环节
     */
    public static Ac getStart(List<Ac> acList) {
        for (Ac ac : acList) {
            if (ac.getIsStart() == 1) {
                return ac;
            }
        }
        return null;
    }

    /**
     * 
     * <p>
     * 判断环节是否结束节点的工作
     * </p>
     * <p>
     * 是否没有流转流出
     * </p>
     * 
     * @author 孙朝辉
     * @param wi
     *            工作
     * @return 是/否
     */
    public static boolean isEndWi(Wi wi) {
        return wi.getAc().getIsEnd() == 1;
    }

    /**
     * 
     * <p>
     * 查询指定节点的直接前/后置的按照条件表达式可到达的节点,如果是自动节点的,则递归查询
     * </p>
     * <p>
     * </p>
     * 
     * @author 孙朝辉
     * @param flag
     *            前/后
     * @param currentAc
     *            当前"环节"
     * @param next_a_or_from_a_acs
     *            前/后置所有Ac
     * @param next_a_or_from_a_trs
     *            前/后置所有Tr
     * @param gvs
     *            全局变量
     * @return NodeIds
     */
    public static List<Ac> getNodeIdsOfFrom1OrNext1ListDeepSearchAuto(FromOrNext flag, Ac currentAc, List<Ac> next_a_or_from_a_acs,
            List<Tr> next_a_or_from_a_trs, Gvs gvs) {

        Map<Ac, List<Tr>> next1OrFrom1TrMap = new HashMap<Ac, List<Tr>>();

        // Step1.<NodeId,Ai>
        Map<String, Ac> nodeId2AiMap = new HashMap<String, Ac>();
        nodeId2AiMap.put(currentAc.getNodeId(), currentAc);

        for (Ac ac : next_a_or_from_a_acs) {
            nodeId2AiMap.put(ac.getNodeId(), ac);
        }

        // Step2.<Ai,List<Tr>>
        String next1OrFrom1Tr = flag == FromOrNext.FROM ? currentAc.getFrom_tr_1() : currentAc.getNext_tr_1();
        Map<String, Tr> trMap = CollectionUtils.collectAsMap(next_a_or_from_a_trs, "trId");

        List<String> trIds = StringHelper.splitAsStringList(next1OrFrom1Tr, "-");
        List<Tr> trs = FlowUtils.filterByTrIds(trIds, trMap);
        next1OrFrom1TrMap.put(currentAc, trs);

        for (Ac theAc : next_a_or_from_a_acs) {
            next1OrFrom1Tr = flag == FromOrNext.FROM ? theAc.getFrom_tr_1() : theAc.getNext_tr_1();
            trIds = StringHelper.splitAsStringList(next1OrFrom1Tr, "-");

            trs = FlowUtils.filterByTrIds(trIds, trMap);
            next1OrFrom1TrMap.put(theAc, trs);
        }

        // Step3.
        List<Ac> pass2AcList = new ArrayList<Ac>();
        List<Ac> workList = new ArrayList<Ac>();
        workList.add(currentAc);

        while (workList.size() > 0) {

            List<Ac> workListTmp = new ArrayList<Ac>();
            for (Ac theAc : workList) {
                List<Tr> trsList = next1OrFrom1TrMap.get(theAc);

                for (Tr next1OrFrom1 : trsList) {
                    String condTr = next1OrFrom1.getCond4Parse();
                    String sourceOrtarget = flag == FromOrNext.FROM ? next1OrFrom1.getSource() : next1OrFrom1.getTarget();
                    Ac xAc = nodeId2AiMap.get(sourceOrtarget);
                    boolean isDefaultTr = next1OrFrom1.getIsDefault() != null && next1OrFrom1.getIsDefault().intValue() == 1;

                    boolean canPass = isDefaultTr || CondUtils.parseCond(condTr, gvs);
                    if (canPass) {
                        boolean xAiIsAuto = FlowUtils.isAuto(xAc);
                        if (xAiIsAuto) {
                            workListTmp.add(xAc);
                        } else if (!pass2AcList.contains(xAc)) {
                            xAc.setAcPriority(next1OrFrom1.getTrPriority());
                            xAc.setIsDefault(isDefaultTr ? 1 : 0);
                            xAc.setCanPass(canPass ? 1 : 0);
                            pass2AcList.add(xAc);
                        }
                    }
                }
            }
            // 准备下一次循环
            workList = workListTmp;
        }

        return pass2AcList;

    }

    /**
     * 
     * <p>
     * </p>
     * <p>
     * </p>
     * 
     * @author 孙朝辉
     * @param currentAc
     *            当前Ac
     * @param next_a_acs
     *            当前Ac后续所有Ac
     * @param next_a_trs
     *            当前Ac后续所有Tr
     * @param gvs
     *            全局变量
     * @param canPassList
     *            可通过
     * @param defaultList
     *            默认
     */
    public static void getNext1ListDeepSearchAuto(Ac currentAc, List<Ac> next_a_acs, List<Tr> next_a_trs, Gvs gvs, List<Ac> canPassList, List<Ac> defaultList) {

        Map<Ac, List<Tr>> next1TrMap = new HashMap<Ac, List<Tr>>();

        // Step1.<NodeId,Ai>
        Map<String, Ac> nodeId2AiMap = new HashMap<String, Ac>();
        nodeId2AiMap.put(currentAc.getNodeId(), currentAc);

        for (Ac ac : next_a_acs) {
            nodeId2AiMap.put(ac.getNodeId(), ac);
        }

        Map<String, Tr> trMap = CollectionUtils.collectAsMap(next_a_trs, "trId");

        String next1Tr = currentAc.getNext_tr_1();
        List<String> tr1Ids = StringHelper.splitAsStringList(next1Tr, "-");
        List<Tr> trs1 = FlowUtils.filterByTrIds(tr1Ids, trMap);
        next1TrMap.put(currentAc, trs1);

        for (Ac theAc : next_a_acs) {
            next1Tr = theAc.getNext_tr_1();
            tr1Ids = StringHelper.splitAsStringList(next1Tr, "-");

            trs1 = FlowUtils.filterByTrIds(tr1Ids, trMap);
            next1TrMap.put(theAc, trs1);
        }

        // Step3.
        List<Ac> workList = new ArrayList<Ac>();
        workList.add(currentAc);

        while (workList.size() > 0) {

            List<Ac> workListTmp = new ArrayList<Ac>();
            for (Ac theAc : workList) {
                List<Tr> trsList = next1TrMap.get(theAc);

                for (Tr next1 : trsList) {
                    String condTr = next1.getCond4Parse();
                    String target = next1.getTarget();
                    Ac xAc = nodeId2AiMap.get(target);
                    boolean isDefaultTr = next1.getIsDefault() != null && next1.getIsDefault().intValue() == 1;
                    boolean canPass = CondUtils.parseCond(condTr, gvs);

                    // 条件允许或者默认分支
                    if (canPass || isDefaultTr) {
                        boolean xAiIsAuto = FlowUtils.isAuto(xAc);
                        if (xAiIsAuto) {
                            workListTmp.add(xAc);
                        } else {
                            if (canPass && !canPassList.contains(xAc)) {
                                xAc.setAcPriority(next1.getTrPriority());
                                xAc.setIsDefault(isDefaultTr ? 1 : 0);
                                canPassList.add(xAc);
                            }
                            if (isDefaultTr && !defaultList.contains(xAc)) {
                                xAc.setAcPriority(next1.getTrPriority());
                                xAc.setIsDefault(isDefaultTr ? 1 : 0);
                                defaultList.add(xAc);
                            }
                        }
                    }
                }
            }
            // 准备下一次循环
            workList = workListTmp;
        }
    }

    /**
     * 
     * <p>
     * 查询指定节点的后置的按照条件表达式可到达的节点,如果是自动节点的,则递归查询
     * </p>
     * <p>
     * </p>
     * 
     * @author 孙朝辉
     * @param currentAc  第一个模板
     *            节点
     * @param acList
     *            所有Ac集合  //获取活动所有模板
     * @param trList
     *            所有Tr集合  //获取所有连线
     * @param gvs
     *            全局变量
     * @param excludeAuto
     *            是否排除自动节点
     * @return Ac集合
     */
    public static List<Ac> getAcListOfNextAList(Ac currentAc, List<Ac> acList, List<Tr> trList, Gvs gvs, boolean excludeAuto) {

        Map<String, Tr> trMap = CollectionUtils.collectAsMap(trList, "trId"); //当前结点可以到达的线条
        Map<String, Ac> acMap = CollectionUtils.collectAsMap(acList, "nodeId"); //当前流程所有节点实例化

        List<Ac> xList = new ArrayList<Ac>();//将要执行AC

        try {
            List<Ac> works = new ArrayList<Ac>();
            works.add(currentAc);//当前AC
            while (works.size() > 0) {
                xList.addAll(works);
                // 分析以work_ac为开始, 可流转到的ac
                List<Ac> tempList = new ArrayList<Ac>();
                for (Ac ac : works) {

                    if (ac == null) {
                        continue;
                    }
                    // Step1.直接流出Tr
                    List<String> nexttr1ids = StringHelper.splitAsStringList(ac.getNext_tr_1(), "-");//获取Ac线条的所有trid
                    
                    List<Tr> nexttr1list = FlowUtils.filterByTrIds(nexttr1ids, trMap);

                    // Step2.直接流出Tr对应的Ac
                    List<String> targets = new ArrayList<String>();
                   
                    // 缓存的
                    List<String> preDecideTargets = new ArrayList<String>();
                    for (Tr tr : nexttr1list) {
                        //String cond = tr.getCond4Parse();
                        String cond = tr.getCond4Parse();
                        
                        //标记Tr是否缺失条件参数
                        boolean ifAllCondParamNameInGvs = CondUtils.ifAllCondParamNameInGvs(gvs, cond);
                        
                        if (ifAllCondParamNameInGvs) {
                            preDecideTargets.add(tr.getTarget());
                        }

                        // Step3.判定,直接流出Tr对应的Ac.NodeIds
                        boolean isTrue = ifAllCondParamNameInGvs && CondUtils.parseCond(cond, gvs);
                        if (isTrue && !targets.contains(tr.getTarget())) {
                            targets.add(tr.getTarget());
                        }
                    }

                    //判断所有Tr条件可分析，并且分析结果为true的 0 => 预先实例化所有条件已经准备好的,可分析的Tr preDecideTargets
                    if(targets.size() == 0){
//                        targets = preDecideTargets;
                    }

                    // /Step4.Ac.NodeIds转换成>Ac
                    List<Ac> nextac1list = FlowUtils.filterByAcIds(targets, acMap);

                    // Step4.准备递归查询Ac
                    if (nextac1list.size() > 0) {
                        tempList.addAll(nextac1list);
                    }
                }
                works = tempList;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        List<Ac> returnList = new ArrayList<Ac>();
        for (Ac test : xList) {
            // 排除自动节点
            if (FlowUtils.isAuto(test) && excludeAuto) {
                continue;
            }
            returnList.add(test);
        }
        returnList = CollectionUtils.distinct(returnList);

        return returnList;
    }

    /**
     * 
     * <p>
     * 依据existsNodeIdList,过滤掉已经存在的Ac
     * </p>
     * <p>
     * </p>
     * 
     * @author 孙朝辉
     * @param yList
     *            待过滤集合
     * @param existsNodeIdList
     *            过滤因子
     * @return Ac集合
     */
    public static List<Ac> excludeExists(List<Ac> yList, List<String> existsNodeIdList) {
        List<Ac> returnList = new ArrayList<Ac>();
        for (Ac y : yList) {
            // 加入returnList
            if (existsNodeIdList.size() == 0 || !existsNodeIdList.contains(y.getNodeId())) {
                returnList.add(y);
            }
        }
        returnList = CollectionUtils.distinct(returnList);
        return returnList;
    }

    /**
     * <p>
     * 是否Ai的Wp
     * </p>
     * <p>
     * </p>
     * 
     * @author 孙朝辉
     * @param wp
     *            工作组
     * @return 是/否
     */
    public static boolean isAiWp(Wp wp) {
        return wp.getIsAi() != null && wp.getIsAi().intValue() == 1;
    }
    
    
    /**
     * <p>是否某种类型的活动</p>
     * <p></p>
     * @author 孙朝辉
     * @param ai
     * @param actypeOutTask
     * @return
     */
    public static boolean isTypeTask(Ac ac, int actypeOutTask) {
        return ac.getAcType() != null && ac.getAcType().intValue() == actypeOutTask;
    }
    
    /**
     * <p>
     * 获取Wp的状态
     * </p>
     * <p>
     * </p>
     * 
     * @author 孙朝辉
     * @param wp
     *            Wp
     * @return Wp状态
     */
    public static int getWpStatus(Wp wp) {
        Integer aiStatus = wp.getAi().getStatus();
        Integer wpStatus = aiStatus;
        if (aiStatus == Ai.STATUS_RUNNING) {
            if (null != wp.getPwiId() && wp.getPwiId().intValue() > 0) {
                if (null != wp.getWis() && wp.getWis().size() > 0){
                    wpStatus = Ai.STATUS_COMPLETE;
                    for (Wi wi : wp.getWis()){
                        if (Ai.STATUS_RUNNING == wi.getStatus()){
                            wpStatus = Ai.STATUS_RUNNING;
                            break;
                        }
                    }
                }
            } else {
                if (wp.getPx().intValue() == wp.getAi().getPx().intValue()) {
                    wpStatus = Ai.STATUS_RUNNING;
                } else if (wp.getPx().intValue() < wp.getAi().getPx().intValue()) {
                    wpStatus = Ai.STATUS_COMPLETE;
                //参与人为空的会自动跳过即已完成
                } else if (StringUtils.isBlank(wp.getParticipants())) {
                    wpStatus = Ai.STATUS_COMPLETE;
                } else {
                    wpStatus = Ai.STATUS_CREATED;
                }
            }
        }
        return wpStatus;
    }

    /**
     * <p>
     * 是否退回工作
     * </p>
     * <p>
     * </p>
     * 
     * @author 孙朝辉
     * @param wi
     *            工作
     * @return 是否退回的工作
     */
    public static boolean isBackedWi(Wi wi) {
        return wi.getIsBacked() != null && wi.getIsBacked().intValue() == 1;
    }

    /**
     * <p>
     * 获取Ai.tstamp
     * </p>
     * <p>
     * </p>
     * 
     * @author 孙朝辉
     * @return 时间戳
     */
    public static String getTstamp() {
        return DateUtils.formatDate(new Date(), "yyyyMMddHHmmssSSS");
    }

    /**
     * <p>
     * 是否删除的wp
     * </p>
     * <p>
     * </p>
     * 
     * @author 孙朝辉
     * @param wp
     *            Wp
     * @return 是否删除的Wp
     */
    public static boolean isDeletedWp(Wp wp) {
        return wp != null && wp.getIsDeleted() != null && wp.getIsDeleted().intValue() == 1;
    }

    /**
     * <option value="0">竞争</option>
     * <option value="1">串行</option>
     * <option value="2">会审</option>
     */
    
    /**
     * 是否串行
     * @author 孙朝辉
     * @param wp
     *            工作组
     * @return 是否串行
     */
    public static boolean isChuanxing(Wp wp) {
        return wp.getAssignType() != null && wp.getAssignType().intValue() == 1;
    }
    /**
     * 是否并行
     * @author jun
     * @param wp 工作组
     * @return 是否并行
     */
    public static boolean isBingxing(Wp wp) {
        return wp.getAssignType() != null && wp.getAssignType().intValue() == 0;
    }
    /**
     * 是否会审
     * @author jun
     * @param wp 工作组
     * @return 是否会审
     */
    public static boolean isHuishen(Wp wp) {
        return wp.getAssignType() != null && wp.getAssignType().intValue() == 2;
    }
    
    /**
     * 是否是子模式运行的串行
     * @author jun
     * @param wp 工作组
     * @return 是否是子模式运行的串行
     */
    public static boolean isSubModeAndChuanxing(Wp wp) {
        //getWpType 参考Ac.nodeType
        return isSubMode(wp) && isChuanxing(wp);
    }
    
    /**
     * 是否是子模式运行的并行
     * @author jun
     * @param wp 工作组
     * @return 是否是子模式运行的并行
     */
    public static boolean isSubModeAndBingxing(Wp wp) {
        //getWpType 参考Ac.nodeType
        return isSubMode(wp) && isBingxing(wp);
    }
    
    /**
     * 是否是子模式运行的会审
     * @author jun
     * @param wp 工作组
     * @return 是否是子模式运行的会审
     */
    public static boolean isSubModeAndHuishen(Wp wp) {
        //getWpType 参考Ac.nodeType
        return isSubMode(wp) && isHuishen(wp);
    }
    
    /**
     * 是否以子wp模式运行
     * @author jun
     * @param wp wp
     * @return 是否以子wp模式运行
     */
    public static boolean isSubMode(Wp wp) {
        return wp.getSubMode() != null && wp.getSubMode().intValue() == 1;
    }
    /**
     * <p>
     * 校验参数必须
     * </p>
     * <p>
     * </p>
     * 
     * @author 孙朝辉
     * @param result
     *            FLowResult
     * @param pvs
     *            参数-值对
     */
    public static void checkParams(FlowResult<?> result, Object... pvs) {

        if (pvs != null && pvs.length > 0) {
            for (int i = 0; i + 1 < pvs.length; i += 1) {
                Object p = pvs[i];
                Object v = pvs[i + 1];
                if (v == null || StringUtils.isEmpty(v.toString())) {
                	result.faliure();
                    result.getDebugInfo().addErrDesc(ApiMsgUtils.getMsg(ApiMsgUtils.KEY_COMMON_FIELD_REQUIRED, p));
                }
            }
        }
    }


    public static String getFinishCtrl(Gvs _tvs) {
        return _tvs.get(WsConstant.WP_FINISHCTRL) == null ||  String.valueOf(_tvs.get(WsConstant.WP_FINISHCTRL)).equals(WsConstant.WP_FINISHCTRL_AND) ? 
                AndFinishTypeService.class.getName() : XorFinishTypeService.class.getName();
    }


    public static Integer getAssignType(Gvs _tvs) {
        return _tvs.get(WsConstant.WP_ASSIGNTYPE) == null ? 0 : 
            (_tvs.get(WsConstant.WP_ASSIGNTYPE).equals(WsConstant.WP_ASSIGNTYPE_CHUANXING) ? 1 : 0);
    }


    public static String getOpRole(Gvs _tvs) {
        return (String)_tvs.get(WsConstant.WI_OP_ROLE);
    }


    public static String getDisplayName(Gvs _tvs, String deft) {
       
        String i = (String)_tvs.get(WsConstant.WP_DISPLAYNAME);
        if(StringUtils.isNotEmpty(i)){
            return i;
        }
        return deft;
    }


    public static boolean isAutoOrAutoTask(Ac ac) {
        return FlowUtils.isAuto(ac) || FlowUtils.isTypeTask(ac, Ac.ACTYPE_AUTO);
    }


    public static int getWpType(String _finishCtrl, Integer _assignType) {
       
        return AndFinishTypeService.class.getName().equals(_finishCtrl) ? (_assignType.intValue() == 1 ? 1 : 0) : 0;
    }


    public static boolean isAutoPassByCfgDoWhenNoUsersAtWp(Fl fl) {
//        <option value=""> 
//            
//        </option>
//        <option value="1">
//          挂起
//        </option>
//        <option value="2">
//          跳过
//        </option>
        if(fl.getDoWhenNoUsersAtWp() == null || fl.getDoWhenNoUsersAtWp().intValue() == 2){
            return true;
        }
        else{
            return false;
        }
    }


    public static boolean isWpSuspend(Wp wp) {
        return wp.getIsSuspend() != null && wp.getIsSuspend().intValue() == 1;
    }


}
