package com.xinleju.erp.report.utils;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Map;
import java.util.Stack;

import com.xinleju.erp.flow.models.Tr;

public class SearchStartToEndPath {
	/* 临时保存路径节点的栈 */  
	public  Stack<Node> stack = new Stack<Node>();  
     /* 存储路径的集合 */  
    public  ArrayList<Object[]> sers = new ArrayList<Object[]>();  
    
    /* 此时栈中的节点组成一条所求路径，转储并打印输出 */ 
    public  void showAndSavePath()  
        {  
            Object[] o = stack.toArray(); 
            
            for (int i = 0; i < o.length; i++) {  
                Node nNode = (Node) o[i];             
              //  System.out.print(nNode.getName()+"["+nNode.getId()+"]" + "->");  
            } 
           sers.add(o); /* 转储 */  
           System.out.println("\n");  
    }  
    
    /**
     * 是否是站内节点
     * @param node
     * @return
     */
    public  boolean isNodeInStack(Node node)  
      {  
           Iterator<Node> it = stack.iterator();  
           while (it.hasNext()) {  
        	   Node stackNode  = it.next();  
               if (stackNode.getId().equals(node.getId()))  
                   return true;  
        }  
         return false;  
    }  


    /* 
         * 寻找路径的方法  
         * cNode: 当前的起始节点currentNode 
         * pNode: 当前起始节点的上一节点previousNode 
         * sNode: 最初的起始节点startNode 
         * eNode: 终点endNode 
         */  

    public  boolean getPaths(Node cur_Node, Node pre_Node, Node start_Node, Node end_Node,Map<String,Node> nodeMaps) {
    	  Node nNode = null;  
    	  /* 如果符合条件判断说明出现环路，不能再顺着该路径继续寻路，返回false */  
    	  //没有下一个节点
    	  if (cur_Node != null && pre_Node != null && (cur_Node.getId().equals(pre_Node.getId())))  
    	             return false;  
    	  if (cur_Node != null) {  

    		            /* 起始节点入栈 */  
    	                stack.push(cur_Node);  
    		            /* 如果该起始节点就是终点，说明找到一条路径 */  
    		             if (cur_Node.getId().equals(end_Node.getId()) || cur_Node.getRelationNodes()==null || cur_Node.getRelationNodes().size()==0)  
    		            {  
    		                 /* 转储并打印输出该路径，返回true */  
    		            	 if(cur_Node.getId().equals(end_Node.getId())){
    		                    showAndSavePath();
    		            	 }
    		                 return true;  
    		            }  
    	                /* 如果不是,继续寻路 */  
    		             else  {
    		            	 /*  
        	                  * 从与当前起始节点cNode有连接关系的节点集中按顺序遍历得到一个节点 
        	                  * 作为下一次递归寻路时的起始节点  
    		                */  
    	    		           int i = 0;  
    	    		          // System.out.println("cur_Node===="+cur_Node.getName());
    		            	   nNode = cur_Node.getRelationNodes().get(i);  
    		            	
    		            	   nNode=nodeMaps.get(nNode.getId());
    		            	   while (nNode != null) { 
    		            		   /* 
            		                     * 如果nNode是最初的起始节点或者nNode就是cNode的上一节点或者nNode已经在栈中 ，  
            		                     * 说明产生环路 ，应重新在与当前起始节点有连接关系的节点集中寻找nNode 
    		                        */ 
    		            		    if (pre_Node != null && (nNode.getId().equals(start_Node.getId())  || nNode.getId().equals(pre_Node.getId()) || isNodeInStack(nNode))) {
        		                           i++;  
	        		                       if (i >= cur_Node.getRelationNodes().size())  
	        		                              nNode = null;  
	        		                        else  
	        		                             nNode = cur_Node.getRelationNodes().get(i); 
	        		                             nNode=nodeMaps.get(nNode.getId());
	        		                       continue;  
        		                   }  

	    		            	   /* 以nNode为新的起始节点，当前起始节点cNode为上一节点，递归调用寻路方法 */  
    		            		    cur_Node=nodeMaps.get(cur_Node.getId());
				                    if (getPaths(nNode, cur_Node, start_Node, end_Node,nodeMaps))/* 递归调用 */  
				                    {  
				                    /* 如果找到一条路径，则弹出栈顶节点 */  
				                         stack.pop();  
				                    }  
				                    
				                    /* 继续在与cNode有连接关系的节点集中测试nNode */  
				                    i++;  
				                    if (i >= (cur_Node.getRelationNodes().size()))  
				                        nNode = null;  
				            	    else { 
				            		   nNode = cur_Node.getRelationNodes().get(i);  
				                       nNode=nodeMaps.get(nNode.getId());
				            	    }
				        
    		            	   }
    		            	     
			                    
			                 
    		                  
    		            	   /*  
    		                          * 当遍历完所有与cNode有连接关系的节点后， 
    		                            * 说明在以cNode为起始节点到终点的路径已经全部找到  
    		                    */  
            	               stack.pop();  
            	               return false; 
    		             }
    	  }else{
    		  return false;
    	  }
    }

	public Stack<Node> getStack() {
		return stack;
	}

	public void setStack(Stack<Node> stack) {
		this.stack = stack;
	}

	public ArrayList<Object[]> getSers() {
		return sers;
	}

	public void setSers(ArrayList<Object[]> sers) {
		this.sers = sers;
	}
    
    
    

}
