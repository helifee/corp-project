package com.sitech.sql.parse;

import java.util.List;

import com.sitech.oa.pars.LexType;
import com.sitech.oa.pars.ReservedWord;
import com.sitech.oa.pars.Scanner;
import com.sitech.oa.pars.Token;

public class Scaner extends Scanner{
	private static final int EOF = 0;//结束
	protected void initReservWord2(){
		//super.initReservWord();
		reservedWord.put("select", new ReservedWord("select", LexType.SELECT));
		reservedWord.put("update", new ReservedWord("update", LexType.UPDATE));
		reservedWord.put("delete", new ReservedWord("delete", LexType.DELETE));
		reservedWord.put("insert", new ReservedWord("insert", LexType.INSERT));
		reservedWord.put("as", new ReservedWord("as", LexType.AS));
		reservedWord.put("from", new ReservedWord("from", LexType.FROM));
		reservedWord.put("where", new ReservedWord("where", LexType.WHERE));
		reservedWord.put("by", new ReservedWord("by", LexType.BY));
		reservedWord.put("order", new ReservedWord("order", LexType.ORDER));
		reservedWord.put("group", new ReservedWord("where", LexType.GROUP));
		reservedWord.put("and", new ReservedWord("and", LexType.AND));
		reservedWord.put("or", new ReservedWord("or", LexType.OR));
		reservedWord.put("all", new ReservedWord("all", LexType.ALL));
		reservedWord.put("distinct", new ReservedWord("distinct", LexType.DISTINCT));
		reservedWord.put("into", new ReservedWord("into", LexType.INTO));
		reservedWord.put("set", new ReservedWord("set", LexType.SET));
		reservedWord.put("in", new ReservedWord("in", LexType.IN));
		reservedWord.put("not", new ReservedWord("not", LexType.NOT));
		reservedWord.put("exists", new ReservedWord("exists", LexType.EXISTS));
		reservedWord.put("between", new ReservedWord("between", LexType.BETWEEN));
		reservedWord.put("values", new ReservedWord("values", LexType.VALUES));
		reservedWord.put("union", new ReservedWord("union", LexType.UNION));
		reservedWord.put("like", new ReservedWord("like", LexType.LIKE));
		reservedWord.put("case", new ReservedWord("case", LexType.CASE));
		reservedWord.put("when", new ReservedWord("when", LexType.WHEN));
		reservedWord.put("then", new ReservedWord("then", LexType.THEN));
		reservedWord.put("else", new ReservedWord("else", LexType.ELSE));
		reservedWord.put("end", new ReservedWord("end", LexType.END));
	}
	
	public Scaner(String sql) {
		super(sql);
		initReservWord2();
	}
	
	/*
	 * 处理开始状态，根据读入的字符决定下个要处理状态
	 */
	protected void processStartState(Token curToken, StringBuffer buf){
		int c=getNextChar();
		if(Character.isDigit(c)){
			buf.append((char) c);
			processNumState(curToken,buf);
		}else if(Character.isLetter(c) || c=='_' || c=='%'){
			buf.append((char) c);
			processIDState(curToken,buf);
		}else if(c=='\''){
			buf.append((char)c);
			processCharState(curToken,buf);
		}else if(c=='<'){
			buf.append((char)c);
			processLessEqu(curToken,buf);
		}else if(c=='>'){
			buf.append((char)c);
			processBigEqu(curToken,buf);
		}else if(c=='='){
			buf.append((char)c);
			processEquEqu(curToken,buf);
		}else if(c=='/'){
			buf.append((char)c);
			processComment(curToken,buf);
		}else if(c=='|'){
			buf.append((char)c);
			processDoubleLL(curToken,buf);
		}else if(c=='('){
			buf.append((char)c);
			processOutLink(curToken,buf);
		}else if(c==' ' || c== '\t' || c=='\r') {
			processStartState(curToken,buf);
		}else if(c=='!'){
			buf.append((char)c);
			processDeEq(curToken,buf);
		}else{
			switch(c){
			case EOF:
				curToken.setLex(LexType.ENDFILE);
				buf.append((char) c);
				break;
			case ':':
				curToken.setLex(LexType.MAO);
				buf.append((char) c);
				break;
			case '+':
				curToken.setLex(LexType.PLUS);
				buf.append((char) c);
				break;
			case '-':
				curToken.setLex(LexType.MINUS);
				buf.append((char) c);
				break;
			case '*':
				curToken.setLex(LexType.TIMES);
				buf.append((char) c);
				break;
			case '(':
				curToken.setLex(LexType.LPAREN);
				buf.append((char) c);
				break;
			case ')':
				curToken.setLex(LexType.RPAREN);
				buf.append((char) c);
				break;
			case '[':
				curToken.setLex(LexType.LMIDPAREN);
				buf.append((char) c);
				break;
			case ']':
				curToken.setLex(LexType.RMIDPAREN);
				buf.append((char) c);
				break;
			case ',':
				curToken.setLex(LexType.COMMA);
			    buf.append((char) c);
			    break;
			case '.':
				curToken.setLex(LexType.UNDERANGE);
				buf.append((char)c);
				break;
			case ';':
				curToken.setLex(LexType.SENTENCEEND);
				buf.append((char)c);
				break;
			case '{':
				curToken.setLex(LexType.LBIGPAREN);
				buf.append((char)c);
				break;
			case '}':
				curToken.setLex(LexType.RBIGPAREN);
				buf.append((char)c);
				break;
			case '#':
				curToken.setLex(LexType.POUND);
				buf.append((char)c);
				break;
			case '?':
				curToken.setLex(LexType.CHARC);
				buf.append((char)c);
				break;
			default:
				curToken.setLex(LexType.ERROR);
				break;
			}
		}
	}
	/*
	 * 处理!=
	 */
	protected void processDeEq(Token curToken,StringBuffer buf){
		int c=getNextChar();
		if(c=='='){
			buf.append((char)c);
			curToken.setLex(LexType.DEEQ);
		}else{
			unGetNextChar();
			curToken.setLex(LexType.ERROR);
		}
	}
	/*
	 * 处理(+)
	 */
	protected void processOutLink(Token curToken,StringBuffer buf){
		int c=getNextChar();
		if(c=='+'){
			buf.append((char)c);
			c=getNextChar();
			if(c==')'){
				buf.append((char)c);
				c=getNextChar();
				buf.append((char)c);
				curToken.setLex(LexType.OUTLINK);
			}
		}else{
			unGetNextChar();
			curToken.setLex(LexType.LPAREN);
		}
	}
	/*
	 * 处理字符串
	 */
	protected void processCharState(Token curToken,StringBuffer buf){
		int c=-1;
		do{
			c=getNextChar();
			if(c==92){
				//转义字符不记录
				getNextChar();
				continue;
			}else if(c==0){
				break;
			}
			buf.append((char)c);
		}while(c!='\'');
		curToken.setLex(LexType.CHARC);
		
	}
	/*
	 *  查询保留字
	 */
	protected int reservedLookup(String reserved){
		ReservedWord word=(ReservedWord)reservedWord.get(reserved.toLowerCase());
		if(word!=null){
			return word.getLexType();
		}
		return LexType.ID;
	}
	/*
	 * 处理||
	 */
	protected void processDoubleLL(Token curToken,StringBuffer buf){
		int c=getNextChar();
		if(c=='|'){
			buf.append((char)c);
			curToken.setLex(LexType.DOUBLELL);
		}else{
			unGetNextChar();
			curToken.setLex(LexType.ERROR);
		}
	}
	public void upDateType(String typeName){
		ReservedWord word=new ReservedWord(typeName,LexType.UTYPE);
		reservedWord.put(typeName,word);
	}
	public static void main(String[] args){
		Scaner s=new Scaner("abdsadfdasdf || aksdjf");
		s.genTokenList();
		List l=s.getTokenList();
		for(int i=0;i<l.size();i+=1){
			Token t=(Token)l.get(i);
			System.out.println(t.getSem()+" "+t.getLex());
		}
	}
	

}
