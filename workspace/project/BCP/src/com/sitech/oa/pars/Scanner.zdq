package com.sitech.oa.pars;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.sitech.oa.pars.node.FunctionDec;



public class Scanner {
	private static final int EOF = 0;//结束
	private String sql;
	private ArrayList tokenList;
	private int linePos;
	private int lineNum;
	
	protected Map reservedWord=null;


	public ArrayList getTokenList() {
		return tokenList;
	}
	public Scanner(String sql){
		
		this.sql=sql+'\0';
		linePos=0;
		lineNum=1;
		tokenList=new ArrayList();
		initReservWord();
	}
	

	protected void initReservWord(){
		reservedWord=new HashMap();
		reservedWord.put("utype", new ReservedWord("utype", LexType.UTYPE));
		reservedWord.put("void", new ReservedWord("utype", LexType.VOID));
		reservedWord.put("int", new ReservedWord("utype", LexType.INT));
		reservedWord.put("long", new ReservedWord("utype", LexType.LONG));
		reservedWord.put("float", new ReservedWord("utype", LexType.FLOAT));
		reservedWord.put("double", new ReservedWord("utype", LexType.DOUBLE));
		reservedWord.put("char", new ReservedWord("utype", LexType.CHAR));
		reservedWord.put("include", new ReservedWord("utype", LexType.INCLUDE));
		reservedWord.put("TCtrlInfo", new ReservedWord("utype", LexType.UTYPE));
		reservedWord.put("struct", new ReservedWord("utype", LexType.STRUCT));
		reservedWord.put("typedef", new ReservedWord("utype", LexType.TYPEDEF));
		reservedWord.put("unsigned", new ReservedWord("utype", LexType.UNSIGNED));
		reservedWord.put("CallBackFunc", new ReservedWord("utype", LexType.UTYPE));
		reservedWord.put("TuxInterface", new ReservedWord("TuxInterface", LexType.FUN));
		reservedWord.put("TPSVCINFO", new ReservedWord("TPSVCINFO", LexType.UTYPE));

	}
	/*
	 * 扫描函数生成一个token
	 */
	protected Token scan(){
		Token curToken = new Token();
		StringBuffer buf = new StringBuffer("");
		processStartState(curToken, buf);
		curToken.setSem(buf.toString());
		//保留字处理
		if (curToken.getLex() == LexType.ID){
			curToken.setLex(reservedLookup(curToken.getSem()));
		}
		curToken.setLineNum(lineNum);
		return curToken;
	}
	/*
	 * 
	 */
	public Token seeNextToken(){
		int saveLinePos=this.linePos;
		Token token=this.getNextToken();
		this.linePos=saveLinePos;
		return token;
	}
	/*
	 * 处理开始状态，根据读入的字符决定下个要处理状态
	 */
	protected void processStartState(Token curToken, StringBuffer buf){
		int c=getNextChar();
		if(Character.isDigit(c)){
			buf.append((char) c);
			processNumState(curToken,buf);
		}else if(Character.isLetter(c) || c=='_'){
			buf.append((char) c);
			processIDState(curToken,buf);
		}else if(c==':'){
			buf.append((char) c);
			processAssignState(curToken,buf);
		}else if(c=='"'){
			buf.append((char)c);
			processCharState(curToken,buf);
		}else if(c=='<'){
			buf.append((char)c);
			processLessEqu(curToken,buf);
		}else if(c=='>'){
			buf.append((char)c);
			processBigEqu(curToken,buf);
		}else if(c=='='){
			buf.append((char)c);
			processEquEqu(curToken,buf);
		}else if(c=='/'){
			buf.append((char)c);
			processComment(curToken,buf);
		}else if(c==' ' || c== '\t' || c=='\r') {
			processStartState(curToken,buf);
		}else{
			switch(c){
			case EOF:
				curToken.setLex(LexType.ENDFILE);
				buf.append((char) c);
				break;
			case '+':
				curToken.setLex(LexType.PLUS);
				buf.append((char) c);
				break;
			case '-':
				curToken.setLex(LexType.MINUS);
				buf.append((char) c);
				break;
			case '*':
				curToken.setLex(LexType.TIMES);
				buf.append((char) c);
				break;
			case '(':
				curToken.setLex(LexType.LPAREN);
				buf.append((char) c);
				break;
			case ')':
				curToken.setLex(LexType.RPAREN);
				buf.append((char) c);
				break;
			case '[':
				curToken.setLex(LexType.LMIDPAREN);
				buf.append((char) c);
				break;
			case ']':
				curToken.setLex(LexType.RMIDPAREN);
				buf.append((char) c);
				break;
			case ',':
				curToken.setLex(LexType.COMMA);
			    buf.append((char) c);
			    break;
			case '.':
				curToken.setLex(LexType.UNDERANGE);
				buf.append((char)c);
				break;
			case ';':
				curToken.setLex(LexType.SENTENCEEND);
				buf.append((char)c);
				break;
			case '{':
				curToken.setLex(LexType.LBIGPAREN);
				buf.append((char)c);
				break;
			case '}':
				curToken.setLex(LexType.RBIGPAREN);
				buf.append((char)c);
				break;
			case '#':
				curToken.setLex(LexType.POUND);
				buf.append((char)c);
				break;
			default:
				curToken.setLex(LexType.ERROR);
				break;
			}
		}
	}
	/*
	 * 处理字符串
	 */
	protected void processCharState(Token curToken,StringBuffer buf){
		int c=-1;
		do{
			c=getNextChar();
			if(c==92){
				//转义字符不记录
				getNextChar();
				continue;
			}
			buf.append((char)c);
		}while(c!='"');
		curToken.setLex(LexType.CHARC);
		
	}

	/*
	 * 处理并识别标识符ID单词
	 */
	protected void processIDState(Token curToken, StringBuffer buf){
		int c = getNextChar();
		while (Character.isLetterOrDigit(c) || c=='_' || c=='%') {
			buf.append((char) c);
			c = getNextChar();
		}
		unGetNextChar();
		curToken.setLex(LexType.ID);
		
	}
	/*
	 * 处理<=
	 */
	protected void processLessEqu(Token curToken, StringBuffer buf){
		int c=getNextChar();
		if(c=='='){
			buf.append((char)c);
			curToken.setLex(LexType.LESSEQU);
		}else{
			curToken.setLex(LexType.LT);
			unGetNextChar();
		}
		
	}
	/*
	 * 处理>=
	 */
	protected void processBigEqu(Token curToken, StringBuffer buf){
		int c=getNextChar();
		if(c=='='){
			buf.append((char)c);
			curToken.setLex(LexType.BIGEQU);
		}else{
			curToken.setLex(LexType.GT);
			unGetNextChar();
		}
		
	}
	/*
	 * 处理==
	 */
	protected void processEquEqu(Token curToken, StringBuffer buf){
		int c=getNextChar();
		if(c=='='){
			buf.append((char)c);
			curToken.setLex(LexType.EQUEQU);
		}else{
			curToken.setLex(LexType.EQ);
			unGetNextChar();
		}
		
	}
	/*
	 * 数字处理
	 */
	protected void processNumState(Token curToken, StringBuffer buf){
		int c=getNextChar();
		while (Character.isDigit(c) || c=='.') {
			buf.append((char) c);
			c = getNextChar();
		}
		unGetNextChar();
		curToken.setLex(LexType.INTC);
	}
	/*
	 * 处理:=赋值
	 */
	protected void processAssignState(Token curToken, StringBuffer buf){
		int c=getNextChar();
		if(c=='='){
			curToken.setLex(LexType.ASSIGN);
			buf.append((char) c);
		}else{
			curToken.setLex(LexType.ERROR);
			unGetNextChar();
		}
	}
	/*
	 * 回退
	 */
	protected void unGetNextChar() {
		linePos--;
		if(sql.charAt(linePos)=='\r'){
			lineNum-=1;
		}
		
	}
	/*
	 * 读取下个单词
	 */
	protected int getNextChar() {
		if(linePos<sql.length()){
			char c=sql.charAt(linePos++);
			if(c=='\r'){
				lineNum+=1;
			}
			return (int)c;
		}else{
			return EOF;
		}
	}
	public void genTokenList(){
		Token token = scan();
		while (token.getLex() != LexType.ENDFILE) {
			//过滤掉注释
			if(token.getLex()!=LexType.COMMENT){
				tokenList.add(token);
			}
			token = scan();
		}
		tokenList.add(token);
	}
	/*
	 * 处理注释
	 */
	protected void processComment(Token curToken, StringBuffer buf){
		int c=getNextChar();
		int preChar='/';
		if(c=='*'){
			do{
				buf.append((char)c);
				preChar=c;
				c=getNextChar();
			}while(preChar!='*' || c!='/');
			curToken.setLex(LexType.COMMENT);
		}else if(c=='/'){
			do{
				buf.append((char)c);
				c=getNextChar();
			}while(c!='\r');
			curToken.setLex(LexType.COMMENT);
		}else{
			curToken.setLex(LexType.OVER);
			buf.append((char) c);
			unGetNextChar();
		}
	}
	/*
	 *  查询保留字
	 */
	protected int reservedLookup(String reserved){
		ReservedWord word=(ReservedWord)reservedWord.get(reserved);
		if(word!=null){
			return word.getLexType();
		}
		return LexType.ID;
	}
	/*
	 * 更新函数定义
	 */
	public void upDateFunctionDec(List l){
		int len=l.size();
		for(int i=0;i<len;i+=1){
			FunctionDec f=(FunctionDec)l.get(i);
			String keyWord=f.function.functionName.tokenString;
			ReservedWord word=new ReservedWord(keyWord,LexType.FUN,f.path);
			reservedWord.put(keyWord,word);
		}
	}
	public void upDateFunctionDec(String functionName,String path){
		ReservedWord word=new ReservedWord(functionName,LexType.FUN,path);
		reservedWord.put(functionName,word);
	}
	public void upDateType(String typeName){
		ReservedWord word=new ReservedWord(typeName,LexType.UTYPE);
		reservedWord.put(typeName,word);
	}
	public Token getNextToken(){
		Token token=null;
		//token不能取得注释
		while((token=scan()).getLex()==LexType.COMMENT){}
		return token;
	}
	public String getFunPath(String word){
		ReservedWord w=(ReservedWord)reservedWord.get(word);
		return w.getPath();
	}
}
